<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Anagramm">
    <meta name="theme-color" content="#006449">
    <link rel="manifest" href="manifest.webmanifest">
    <!-- Icon für „Zum Home-Bildschirm“: 180×180 px als apple-touch-icon.png ablegen, dann wird es genutzt -->
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <title>Anagram-Spiel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--game-bg-color, #006449);
            font-family: 'GT Pantheon Display', 'GT Pantheon', Georgia, 'Times New Roman', serif;
            /* Safe Area für iPad/iPhone (Notch, Home-Indicator) bei viewport-fit=cover */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            margin-top: var(--game-container-margin-top, -2rem);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            aspect-ratio: 1640/2360;
            max-width: 100vw;
            max-height: 100vh;
        }

        #fireworks-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        /* Gewinn-Bild: blendet dort ein, wo die oberen Buchstaben waren; Feuerwerk liegt darüber (z-index 1000) */
        #win-image-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.6s ease;
            overflow: visible;
        }
        #win-image-container.visible {
            opacity: 1;
        }
        /* Beim Gewinn Buchstaben ausblenden, damit nur das Bild sichtbar ist */
        #words-container.win-image-visible .word {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.6s ease;
        }
        /* Beim Gewinn Overflow erlauben, damit vergrößertes Bild nicht abgeschnitten wird */
        #words-container.win-image-visible {
            overflow: visible;
        }
        #win-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: 50% 50%;
            /* translateY: Slider 0–100 → -50% bis +50% (immer sichtbar, unabhängig von Container-Seitenverhältnis) */
            transform: translateY(calc(var(--win-image-translate-y, 0) * 1%)) scale(var(--win-image-scale, 1));
        }

        #words-container {
            position: relative;
            width: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--source-line-height, 2rem);
            padding: 1rem 0;
            transition: transform 0.5s ease-out, gap 0.3s ease;
            transform: translateY(0);
        }

        #words-container.shifted-up {
            transform: translateY(-40%);
        }

        .word {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: var(--source-letter-spacing, 0px);
            position: relative;
        }

        .word-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            position: relative;
        }

        @keyframes wobble {
            0%, 100% {
                transform: translate(calc(var(--base-offset-x, 0px) + 0px), calc(var(--base-offset-y, 0px) + 0px)) rotate(calc(var(--base-rotation, 0deg) + 0deg));
            }
            25% {
                transform: translate(calc(var(--base-offset-x, 0px) + calc(var(--wobble-intensity-x, 2px) * -1)), calc(var(--base-offset-y, 0px) + var(--wobble-intensity-y, 1px))) rotate(calc(var(--base-rotation, 0deg) + calc(var(--wobble-intensity-rot, 2deg) * -1)));
            }
            50% {
                transform: translate(calc(var(--base-offset-x, 0px) + var(--wobble-intensity-x, 2px)), calc(var(--base-offset-y, 0px) + calc(var(--wobble-intensity-y, 1px) * -1))) rotate(calc(var(--base-rotation, 0deg) + var(--wobble-intensity-rot, 2deg)));
            }
            75% {
                transform: translate(calc(var(--base-offset-x, 0px) + calc(var(--wobble-intensity-x, 2px) * -0.5)), calc(var(--base-offset-y, 0px) + calc(var(--wobble-intensity-y, 1px) * 2))) rotate(calc(var(--base-rotation, 0deg) + calc(var(--wobble-intensity-rot, 2deg) * -0.5)));
            }
        }

        @keyframes blurPulse {
            0%, 100% {
                filter: blur(0px);
                opacity: 1;
            }
            50% {
                filter: blur(var(--blur-max, 3px));
                opacity: var(--blur-opacity-min, 0.7);
            }
        }

        .letter {
            font-size: var(--letter-size, 3rem);
            color: white;
            font-weight: normal;
            position: relative;
            cursor: grab;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            transition: filter 0.3s ease, opacity 0.3s ease, letter-spacing 0.3s ease;
            width: var(--letter-size, 3rem);
            height: var(--letter-size, 3rem);
            min-width: var(--letter-size, 3rem);
            min-height: var(--letter-size, 3rem);
            display: flex;
            align-items: center;
            justify-content: center;
            letter-spacing: var(--source-letter-spacing, 0px);
            /* Animation wird individuell per JavaScript gesetzt */
            /* Transform affects both visual position and hitbox */
            transform-origin: center center;
        }

        .letter svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Größen und Stile basierend auf Zielwort-Zuordnung */
        .letter[data-for-christoffel="true"] {
            font-size: var(--letter-size, 3rem);
        }

        .letter[data-for-von="true"] {
            font-size: var(--letter-size, 3rem);
        }

        .letter[data-for-grimmelshausen="true"] {
            font-size: var(--letter-size, 3rem);
        }

        .letter.dragging {
            cursor: grabbing;
            z-index: 1000;
            opacity: 0.8;
            animation: none;
            filter: blur(0px) !important;
            transition: none !important;
        }

        /* Beim Gewinn: Dragging deaktivieren */
        body.win-mode .letter {
            pointer-events: none;
            cursor: default;
        }

        .letter[data-in-slot="true"] {
            animation: none;
            filter: blur(0px) !important;
        }

        .letter-placeholder {
            width: var(--letter-size, 3rem);
            height: var(--letter-size, 3rem);
            min-width: var(--letter-size, 3rem);
            min-height: var(--letter-size, 3rem);
            display: inline-block;
            opacity: 0.3;
            pointer-events: none;
            visibility: visible;
        }

        #drop-zone {
            position: absolute;
            bottom: 5%;
            left: 5%;
            right: 5%;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: var(--target-line-height, 1rem);
            padding: 1rem;
            transition: opacity 0.5s ease-out, visibility 0.5s ease-out, gap 0.3s ease;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        #drop-zone.visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            display: flex;
        }

        .word-row-slots {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: var(--target-letter-spacing, 0px);
            transition: gap 0.3s ease;
        }

        .drop-slot {
            /* Größen werden dynamisch basierend auf Schriftgröße gesetzt */
            width: var(--slot-width, 3rem);
            height: var(--slot-height, 3.9rem);
            border-bottom: var(--underline-thickness, 2px) solid white;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding-bottom: var(--underline-spacing, 0.5rem);
            box-sizing: border-box;
        }

        .drop-slot.filled {
            border-bottom: none;
            padding-bottom: 0;
        }

        /* Einheitliche Schrift- und Slotgrößen für alle Wörter */
        .word-row-slots .drop-slot {
            font-size: var(--letter-size, 3rem);
            width: var(--slot-width, 3rem);
            height: var(--slot-height, 3.9rem);
        }

        .word-row-slots .drop-slot .letter {
            font-size: var(--letter-size, 3rem);
        }

        /* Vertikaler Pfeil */
        #drop-arrow {
            position: absolute;
            left: 50%;
            top: var(--arrow-pos-y, -9rem);
            transform: translateX(-50%);
            font-size: 3rem;
            color: white;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
            pointer-events: none;
        }

        #drop-arrow svg {
            width: var(--arrow-size, 7rem);
            height: var(--arrow-size, 7rem);
            display: block;
        }

        #drop-arrow.visible {
            opacity: 1;
            visibility: visible;
        }


        .drop-slot .letter {
            /* Schriftgröße wird von spezifischen Regeln pro Wort gesetzt */
            position: absolute;
            transform: translateX(-50%) !important;
            bottom: calc(var(--underline-spacing, 0.5rem) + var(--underline-thickness, 2px)) !important;
            top: auto !important;
            left: 50%;
            letter-spacing: 0 !important;
            transition: none;
            /* Inhalt (SVG) am unteren Rand ausrichten, damit Glyphen-Baseline auf der Unterstreichung sitzt */
            align-items: flex-end;
        }

        @media (orientation: portrait) {
            #game-container {
                aspect-ratio: 1640/2360;
            }
        }

        @media (orientation: landscape) {
            #game-container {
                aspect-ratio: 1640/2360; /* Portrait auch bei Landscape-Orientierung beibehalten */
                max-width: calc(100vh * (1640/2360)); /* Breite basierend auf Höhe */
                max-height: 100vh;
                width: calc(100vh * (1640/2360)); /* Feste Breite für Zentrierung */
                margin: 0 auto; /* Zentrierung horizontal */
            }
        }

        /* iPad A16 / 10th Gen: Viewport in CSS-Pixeln (z. B. 820×1180 Portrait), gleiches Seitenverhältnis 1640/2360 */
        @media screen and (min-width: 800px) and (min-height: 1100px) and (orientation: portrait),
               screen and (min-width: 1100px) and (min-height: 800px) and (orientation: landscape) {
            .letter {
                font-size: 6rem;
                min-width: 65px;
                min-height: 65px;
            }

            #words-container {
                width: 85%;
                padding: 1.5rem 0;
            }

            #drop-zone {
                bottom: 6%;
                padding: 1.5rem;
            }

            #burger-menu {
                width: 60px;
                height: 60px;
                top: 15px;
                right: 15px;
            }

            #burger-menu span {
                width: 30px;
                height: 4px;
            }

            #controls-panel {
                top: 85px;
                right: 15px;
                padding: 1.25rem;
                font-size: 1rem;
                min-width: 280px;
                max-width: 320px;
            }

            #drop-arrow {
                font-size: 3.5rem;
                top: var(--arrow-pos-y, -9rem);
            }
        }

        #burger-menu {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10001;
            cursor: pointer;
            width: 50px;
            height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            padding: 10px;
            backdrop-filter: blur(10px);
            transition: background 0.3s ease;
        }

        #burger-menu:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        #burger-menu span {
            display: block;
            width: 25px;
            height: 3px;
            background: white;
            border-radius: 2px;
            transition: all 0.3s ease;
        }

        #burger-menu.active span:nth-child(1) {
            transform: rotate(45deg) translate(8px, 8px);
        }

        #burger-menu.active span:nth-child(2) {
            opacity: 0;
        }

        #burger-menu.active span:nth-child(3) {
            transform: rotate(-45deg) translate(7px, -7px);
        }

        #controls-panel {
            position: fixed;
            top: 70px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 8px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 0.9rem;
            z-index: 10000;
            min-width: 250px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            transform: translateX(calc(100% + 20px));
            transition: transform 0.3s ease-out;
            max-height: calc(100vh - 90px);
            overflow-y: auto;
        }

        #controls-panel.visible {
            transform: translateX(0);
        }

        #controls-panel h3 {
            margin-bottom: 0.5rem;
            font-size: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 0.5rem;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.3rem;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 0.3rem;
        }

        .control-group .value-display {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.8);
            text-align: right;
        }

        .control-group input[type="color"] {
            display: block;
            width: 56px;
            height: 56px;
            padding: 0;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            cursor: pointer;
            background: none;
            margin-bottom: 0.3rem;
            -webkit-appearance: none;
            appearance: none;
        }
        .control-group input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .control-group input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
        .control-group input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }

        .control-section {
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .letter {
                font-size: 3rem;
            }
            
            /* Slot-Größen werden dynamisch über CSS-Variablen gesetzt, 
               daher keine festen Größen mehr nötig - Größen werden von updateTextSizes() dynamisch gesetzt */

            #burger-menu {
                top: 5px;
                right: 5px;
                width: 45px;
                height: 45px;
            }

            #controls-panel {
                top: 60px;
                right: 5px;
                padding: 0.75rem;
                font-size: 0.8rem;
                min-width: 200px;
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div id="burger-menu">
        <span></span>
        <span></span>
        <span></span>
    </div>
    <div id="controls-panel">
        <h3>Einstellungen</h3>
        
        <div class="control-section">
            <h4>Hintergrund</h4>
            <div class="control-group">
                <label for="bg-color">Hintergrundfarbe</label>
                <input type="color" id="bg-color" value="#006449" title="Hintergrundfarbe wählen">
                <div class="value-display" id="bg-color-value">#006449</div>
            </div>
        </div>

        <div class="control-section">
            <h4>Container</h4>
            <div class="control-group">
                <label for="container-margin-top">Vertikale Position (rem)</label>
                <input type="range" id="container-margin-top" min="-8" max="2" step="0.5" value="-2">
                <div class="value-display" id="container-margin-top-value">-2rem</div>
            </div>
        </div>

        <div class="control-section">
            <h4>Bewegung der Buchstaben</h4>
            <div class="control-group">
                <label for="wobble-intensity-x">Seitliche Bewegung (px)</label>
                <input type="range" id="wobble-intensity-x" min="0" max="10" step="0.5" value="2">
                <div class="value-display" id="wobble-intensity-x-value">2px</div>
            </div>
            <div class="control-group">
                <label for="wobble-intensity-y">Höhenbewegung (px)</label>
                <input type="range" id="wobble-intensity-y" min="0" max="10" step="0.5" value="4.5">
                <div class="value-display" id="wobble-intensity-y-value">4.5px</div>
            </div>
            <div class="control-group">
                <label for="wobble-intensity-rot">Drehung (Grad)</label>
                <input type="range" id="wobble-intensity-rot" min="0" max="10" step="0.5" value="5.5">
                <div class="value-display" id="wobble-intensity-rot-value">5.5°</div>
            </div>
            <div class="control-group">
                <label for="wobble-duration-min">Bewegungsgeschwindigkeit (min)</label>
                <input type="range" id="wobble-duration-min" min="1" max="8" step="0.5" value="8">
                <div class="value-display" id="wobble-duration-min-value">8s</div>
            </div>
            <div class="control-group">
                <label for="wobble-duration-max">Bewegungsgeschwindigkeit (max)</label>
                <input type="range" id="wobble-duration-max" min="1" max="8" step="0.5" value="6.5">
                <div class="value-display" id="wobble-duration-max-value">6.5s</div>
            </div>
        </div>

        <div class="control-section">
            <h4>Unschärfe-Effekt</h4>
            <div class="control-group">
                <label for="blur-max">Unschärfe-Stärke (px)</label>
                <input type="range" id="blur-max" min="0" max="10" step="0.5" value="6">
                <div class="value-display" id="blur-max-value">6px</div>
            </div>
            <div class="control-group">
                <label for="blur-opacity-min">Transparenz (min)</label>
                <input type="range" id="blur-opacity-min" min="0" max="1" step="0.1" value="0.7">
                <div class="value-display" id="blur-opacity-min-value">0.7</div>
            </div>
            <div class="control-group">
                <label for="blur-duration-min">Unschärfe-Geschwindigkeit (min)</label>
                <input type="range" id="blur-duration-min" min="1" max="8" step="0.5" value="2.5">
                <div class="value-display" id="blur-duration-min-value">2.5s</div>
            </div>
            <div class="control-group">
                <label for="blur-duration-max">Unschärfe-Geschwindigkeit (max)</label>
                <input type="range" id="blur-duration-max" min="1" max="8" step="0.5" value="3.5">
                <div class="value-display" id="blur-duration-max-value">3.5s</div>
            </div>
        </div>

        <div class="control-section">
            <h4>Ausgangstext</h4>
            <div class="control-group">
                <label for="source-line-height">Zeilenabstand (rem)</label>
                <input type="range" id="source-line-height" min="0.5" max="5" step="0.1" value="3.8">
                <div class="value-display" id="source-line-height-value">3.8rem</div>
            </div>
            <div class="control-group">
                <label for="source-letter-spacing">Abstand zwischen Buchstaben (px)</label>
                <input type="range" id="source-letter-spacing" min="-5" max="20" step="0.5" value="-2">
                <div class="value-display" id="source-letter-spacing-value">-2px</div>
            </div>
        </div>

        <div class="control-section">
            <h4>Schriftgröße</h4>
            <div class="control-group">
                <label for="letter-size">Schriftgröße (rem)</label>
                <input type="range" id="letter-size" min="2" max="10" step="0.1" value="3.8">
                <div class="value-display" id="letter-size-value">3.8rem</div>
            </div>
            <div class="control-group">
                <label for="target-line-height">Zeilenabstand (rem)</label>
                <input type="range" id="target-line-height" min="0.5" max="5" step="0.1" value="0.7">
                <div class="value-display" id="target-line-height-value">0.7rem</div>
            </div>
            <div class="control-group">
                <label for="target-letter-spacing">Abstand zwischen Buchstaben (px)</label>
                <input type="range" id="target-letter-spacing" min="-5" max="20" step="0.5" value="5">
                <div class="value-display" id="target-letter-spacing-value">5px</div>
            </div>
        </div>

        <div class="control-section">
            <h4>Unterstriche</h4>
            <div class="control-group">
                <label for="underline-thickness">Dicke der Unterstriche (px)</label>
                <input type="range" id="underline-thickness" min="1" max="10" step="0.5" value="1">
                <div class="value-display" id="underline-thickness-value">1px</div>
            </div>
            <div class="control-group">
                <label for="underline-spacing">Abstand zu den Buchstaben (rem)</label>
                <input type="range" id="underline-spacing" min="0" max="2" step="0.1" value="0">
                <div class="value-display" id="underline-spacing-value">0rem</div>
            </div>
        </div>

        <div class="control-section">
            <h4>Pfeil</h4>
            <div class="control-group">
                <label for="arrow-size">Größe des Pfeils (rem)</label>
                <input type="range" id="arrow-size" min="4" max="10" step="0.1" value="5.8">
                <div class="value-display" id="arrow-size-value">5.8rem</div>
            </div>
            <div class="control-group">
                <label for="arrow-pos-y">Position vertikal (rem)</label>
                <input type="range" id="arrow-pos-y" min="0" max="100" step="5" value="80">
                <div class="value-display" id="arrow-pos-y-value">-7.2rem</div>
            </div>
        </div>

        <div class="control-section">
            <h4>Gewinn-Bild</h4>
            <div class="control-group">
                <label for="win-image-pos-y">Position vertikal (%)</label>
                <input type="range" id="win-image-pos-y" min="0" max="100" step="1" value="55">
                <div class="value-display" id="win-image-pos-y-value">55%</div>
            </div>
            <div class="control-group">
                <label for="win-image-scale">Größe (%)</label>
                <input type="range" id="win-image-scale" min="75" max="175" step="1" value="110">
                <div class="value-display" id="win-image-scale-value">110%</div>
            </div>
        </div>

        <div class="control-section">
            <h4>Debug</h4>
            <div class="control-group">
                <button id="trigger-win-button" style="width: 100%; padding: 0.5rem; background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; color: white; cursor: pointer; font-family: Arial, sans-serif; font-size: 0.9rem;">Gewinn-Event auslösen</button>
            </div>
        </div>
    </div>

    <canvas id="fireworks-canvas"></canvas>
    <div id="game-container">
        <div id="words-container">
            <div id="win-image-container" aria-hidden="true">
                <img src="Geschafft Feuerwerk.jpg" alt="">
            </div>
            <div class="word" id="word-samuel"></div>
            <div class="word-row">
                <div class="word" id="word-greifn"></div>
                <div class="word" id="word-son"></div>
            </div>
            <div class="word" id="word-vom"></div>
            <div class="word" id="word-hirschfelt"></div>
        </div>
        <div id="drop-zone">
            <div id="drop-arrow" aria-hidden="true">
                <svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 100 100" role="img" aria-label="Pfeil">
                    <style type="text/css">
                        .st0{fill:#FFFFFF;}
                        .st1{clip-path:url(#SVGID_00000001661299273632443730000010025928977244214452_);fill:none;stroke:#FFFFFF;stroke-width:0.75;}
                    </style>
                    <polygon class="st0" points="50.37,76.42 50.37,6.17 49.62,6.17 49.62,76.42 41.27,69.85 41.27,69.86 50,93.83 58.73,69.85 "/>
                </svg>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // KONFIGURATION & KONSTANTEN
        // ============================================================================
        
        /** Ziel-Lösung des Anagram-Spiels */
        const targetSolution = 'CHRISTOFFEL VON GRIMMELSHAUSEN';
        
        /** Ausgangswörter für das Anagram */
        const words = ['SAMUEL', 'GREIFN', 'SON', 'VOM', 'HIRSCHFELT'];
        
        /** Timeout für automatischen Reset bei Inaktivität (in Millisekunden) */
        const RESET_TIMEOUT = 60000; // 60 Sekunden
        
        // Performance-Konstanten
        const ANIMATION_DURATION = 500; // ms
        const ANIMATION_DURATION_LONG = 800; // ms
        const STAGGER_DELAY = 30; // ms
        const SWAP_DELAY = 100; // ms
        const REFLOW_DELAY = 10; // ms
        const Z_INDEX_DRAGGING = 1000;
        const Z_INDEX_ANIMATION = 2000;
        
        // ============================================================================
        // SVG-BUCHSTABEN
        // ============================================================================
        
        /**
         * SVG-Inhalte für alle Buchstaben (inline eingebunden)
         */
        const letterSVGs = {
            'A': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0.52 100 100" style="enable-background:new 0 0.52 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><path class="st0" d="M36.36,56.5l9.47-25.48l9.56,25.48H36.36z M37.4,82.52l-8.78-5.26l7.3-19.6h19.99l7.56,20.14l-8.78,4.72v0.09h25.29v-0.09l-7.13-4.72L49.74,17.39h-0.09L27.23,77.26l-7.21,5.26v0.09H37.4V82.52z"/></svg>',
            'C': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 1.23 100 100" style="enable-background:new 0 1.23 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><g><path class="st0" d="M54.65,83.23c7.73,0,15.64-1.51,22.07-4.01l3.74-19.69h-0.09L67.6,79.22c-3.39,1.69-7.3,2.85-12.08,2.85c-15.38,0-26.16-13.99-26.16-32.43c0-18.53,11.04-30.56,26.77-30.56c4.78,0,8.86,0.98,12.77,3.74l8.17,16.84h0.09v-22.9h-0.09l-4.87,3.65c-4.95-1.51-10.25-2.49-15.82-2.49c-21.72,0-36.84,14.43-36.84,33.06S34.66,83.23,54.65,83.23"/></g></svg>',
            'E': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0.61 100 100" style="enable-background:new 0 0.61 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><polygon class="st0" points="24.93,82.61 71.68,82.61 75.07,62.65 74.98,62.65 62.9,81.45 42.4,81.45 42.4,49.73 56.56,49.73 62.64,61.32 62.73,61.32 62.73,37.08 62.64,37.08 56.56,48.57 42.4,48.57 42.4,20.95 62.9,20.95 70.81,37.97 70.9,37.97 70.9,17.39 70.81,17.39 66.9,19.8 24.93,19.8 24.93,19.88 33.53,24.52 33.53,77.89 24.93,82.52 "/></svg>',
            'F': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 -16.78 100 100" style="enable-background:new 0 -16.78 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><polygon class="st0" points="27.45,65.22 56.91,65.22 56.91,65.13 44.92,60.5 44.92,33.23 59.08,33.23 65.16,44.82 65.25,44.82 65.25,20.58 65.16,20.58 59.08,32.08 44.92,32.08 44.92,3.56 64.47,3.56 72.46,20.49 72.55,20.49 72.55,0 72.46,0 68.55,2.41 27.45,2.41 27.45,2.49 36.05,7.13 36.05,60.5 27.45,65.13 "/></svg>',
            'G': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 1.23 100 100" style="enable-background:new 0 1.23 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><path class="st0" d="M52.48,83.23c5.39,0,10.86-0.89,17.29-3.47l6.17-6.5V57.4l6.78-4.63v-0.09h-25.9v0.09l10.34,4.72v20.05c-3.3,2.67-7.99,4.54-13.82,4.54c-15.55,0-26.24-14.88-26.24-32.79c0-18.8,11.3-30.2,26.59-30.2c4.43,0,8.43,0.89,11.91,2.94l8.43,17.64h0.09v-22.9h-0.09l-4.78,3.56c-4.52-1.6-9.99-2.41-14.95-2.41c-22.25,0-37.02,15.15-37.02,33.41C17.28,69.6,31.27,83.23,52.48,83.23"/></svg>',
            'H': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 -0.59 100 100" style="enable-background:new 0 -0.59 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><polygon class="st0" points="57,18.59 57,18.68 65.51,23.4 65.51,47.28 34.49,47.28 34.49,23.49 43.09,18.68 43.09,18.59 17.02,18.59 17.02,18.68 25.62,23.4 25.62,76.6 17.02,81.32 17.02,81.41 43.09,81.41 43.09,81.32 34.49,76.51 34.49,48.44 65.51,48.44 65.51,76.6 57,81.32 57,81.41 82.98,81.41 82.98,81.32 74.38,76.51 74.38,23.49 82.98,18.68 82.98,18.59 "/></svg>',
            'I': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 -0.59 100 100" style="enable-background:new 0 -0.59 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><polygon class="st0" points="36.97,81.41 63.03,81.41 63.03,81.32 54.43,76.51 54.43,23.49 63.03,18.68 63.03,18.59 36.97,18.59 36.97,18.68 45.57,23.4 45.57,76.6 36.97,81.32 "/></svg>',
            'L': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 -0.59 100 100" style="enable-background:new 0 -0.59 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><polygon class="st0" points="25.54,18.59 25.54,18.68 34.14,23.4 34.14,76.68 25.54,81.32 25.54,81.41 71.07,81.41 74.46,58.95 74.38,58.95 62.04,80.25 43,80.25 43,23.49 51.61,18.68 51.61,18.59 "/></svg>',
            'M': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0.25 100 100" style="enable-background:new 0 0.25 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><polygon class="st0" points="45.7,82.25 45.79,82.25 66.38,24.96 71.77,75.75 63.25,80.47 63.25,80.56 89.06,80.56 89.06,80.47 80.55,75.66 74.9,22.47 83.24,17.84 83.24,17.75 65.77,17.75 65.77,22.74 49.61,67.73 31.97,17.75 16.07,17.75 16.07,17.84 24.58,22.38 19.54,75.75 10.94,80.47 10.94,80.56 29.71,80.56 29.71,80.47 20.93,75.75 25.54,25.5 "/></svg>',
            'N': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0.30 100 100" style="enable-background:new 0 0.30 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><polygon class="st0" points="72.51,82.3 72.59,82.3 72.59,22.87 81.46,17.79 81.46,17.7 60.78,17.7 60.78,17.79 71.38,22.78 71.38,66.97 31.14,17.7 18.8,17.7 18.8,17.79 27.41,27.15 27.41,75.35 18.54,80.43 18.54,80.52 39.22,80.52 39.22,80.43 28.71,75.44 28.71,28.66 "/></svg>',
            'O': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0.65 100 100" style="enable-background:new 0 0.65 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><path class="st0" d="M50.91,81.5c-17.03,0-24.85-18.53-24.85-34.04c0-15.86,8.95-28.96,23.03-28.96c17.03,0,24.85,18.53,24.85,34.04C73.94,68.49,64.99,81.5,50.91,81.5 M50.04,82.65c19.47,0,33.63-13.99,33.63-32.7c0-18.62-14.25-32.61-33.72-32.61s-33.63,13.99-33.63,32.7C16.33,68.67,30.58,82.65,50.04,82.65"/></svg>',
            'R': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 -0.59 100 100" style="enable-background:new 0 -0.59 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><path class="st0" d="M39.66,48.44V19.75h3.39c10.43,0,14.51,4.63,14.51,12.47c0,7.04-3.22,12.38-14.86,15.41L39.66,48.44z M22.19,81.41h27.63v-0.09L39.66,76.6v-27l3.13-0.8l24.25,32.61h10.77v-0.09L51.74,46.39c9.39-3.12,15.55-7.75,15.55-14.88c0-6.5-5.21-12.92-21.12-12.92H22.19v0.09l8.6,4.63V76.6l-8.6,4.72V81.41z"/></svg>',
            'S': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 1.23 100 100" style="enable-background:new 0 1.23 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><g><path class="st0" d="M47.74,83.23c13.38,0,23.11-8.11,23.11-19.78c0-7.13-3.21-11.58-11.3-16.04l-10.17-5.52c-6.17-3.39-8.43-6.24-8.43-11.32c0-6.77,4.95-11.58,11.99-11.58c2.69,0,5.21,0.71,7.39,2.23l8.17,18.44h0.09v-22.9h-0.09l-5.04,3.3c-3.22-1.43-6.61-2.14-10.08-2.14c-11.21,0-19.73,7.75-19.73,17.2c0,6.33,3.65,11.23,10.34,14.97l10.17,5.7c6.87,3.74,9.12,6.77,9.12,12.21c0,8.64-6.17,14.17-14.51,14.17c-2.43,0-4.69-0.53-6.69-1.51L29.23,59.8h-0.09l3.65,20.4C37.49,82.16,43.05,83.23,47.74,83.23"/></g></svg>',
            'T': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0.61 100 100" style="enable-background:new 0 0.61 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><polygon class="st0" points="75.72,17.39 71.81,19.8 28.1,19.8 24.28,17.39 24.19,17.39 24.19,40.29 24.28,40.29 32.27,20.95 45.57,20.95 45.57,77.71 35.23,82.52 35.23,82.61 64.68,82.61 64.68,82.52 54.43,77.71 54.43,20.95 67.73,20.95 75.72,40.29 75.81,40.29 75.81,17.39 "/></svg>',
            'U': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0.03 100 100" style="enable-background:new 0 0.03 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><g><path class="st0" d="M50.17,82.03c14.34,0,22.85-9.53,22.85-24.86V23.14l8.6-5.08v-0.09H62.86v0.09l8.86,5.08v33.32c0,14.26-6.95,21.47-17.73,21.47c-11.12,0-18.16-7.22-18.16-21.56V22.78l8.86-4.72v-0.09H18.37v0.09l8.6,4.72v34.39C26.97,72.5,35.49,82.03,50.17,82.03"/></g></svg>',
            'V': '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0.30 100 100" style="enable-background:new 0 0.30 100 100;" xml:space="preserve"><style type="text/css">.st0{fill:#FFFFFF;}</style><polygon class="st0" points="20.11,17.79 27.23,22.42 50,82.3 50.17,82.3 72.68,23.14 79.89,17.79 79.89,17.7 62.51,17.7 62.51,17.79 71.38,23.05 54,68.4 36.62,22.42 45.39,17.79 45.39,17.7 20.11,17.7 "/></svg>'
        };
        
        /**
         * Gibt das SVG für einen Buchstaben zurück
         * @param {string} letter - Der Buchstabe
         * @returns {string} - SVG-Inhalt als String
         */
        function getLetterSVG(letter) {
            return letterSVGs[letter.toUpperCase()] || '';
        }
        
        // ============================================================================
        // BUCHSTABEN-ZUORDNUNG
        // ============================================================================
        
        /**
         * Eindeutige Buchstaben-Zuordnung basierend auf den Angaben
         * Format: 'sourceWordIndex-sourceLetterIndex': [targetWordIndex, targetLetterIndex]
         * Jeder Buchstabe hat genau eine korrekte Position im Zielwort
         */
        const letterMapping = {
            // CHRISTOFFEL
            // c -> 5. Buchstabe von HIRSCHFELT (Index 4, Position 4 = C)
            '4-4': [0, 0], // C -> Position 0 in CHRISTOFFEL
            // h -> 1. Buchstabe von HIRSCHFELT (Index 4, Position 0 = H)
            '4-0': [0, 1], // H -> Position 1 in CHRISTOFFEL
            // r -> 3. Buchstabe von HIRSCHFELT (Index 4, Position 2 = R)
            '4-2': [0, 2], // R -> Position 2 in CHRISTOFFEL
            // i -> 4. Buchstabe von GREIFNSON = Index 3 in GREIFN (I)
            '1-3': [0, 3], // I -> Position 3 in CHRISTOFFEL
            // s -> 1. Buchstabe von SAMUEL (Index 0, Position 0 = S)
            '0-0': [0, 4], // S -> Position 4 in CHRISTOFFEL
            // t -> letzte Buchstabe von HIRSCHFELT (Index 4, Position 9 = T)
            '4-9': [0, 5], // T -> Position 5 in CHRISTOFFEL
            // o -> 8. Buchstabe von GREIFNSON = Position 1 in SON (Index 2, Position 1 = O)
            '2-1': [0, 6], // O -> Position 6 in CHRISTOFFEL
            // f -> 5. Buchstabe von GREIFN (Index 1, Position 4 = F)
            '1-4': [0, 7], // F -> Position 7 in CHRISTOFFEL
            // f -> 7. Buchstabe von HIRSCHFELT (Index 4, Position 6 = F)
            '4-6': [0, 8], // F -> Position 8 in CHRISTOFFEL
            // e -> 5. Buchstabe von SAMUEL (Index 0, Position 4 = E)
            '0-4': [0, 9], // E -> Position 9 in CHRISTOFFEL
            // l -> letzte Buchstabe von SAMUEL (Index 0, Position 5 = L)
            '0-5': [0, 10], // L -> Position 10 in CHRISTOFFEL
            
            // VON
            // v -> 1. Buchstabe von VOM (Index 3, Position 0 = V)
            '3-0': [1, 0], // V -> Position 0 in VON
            // o -> 2. Buchstabe von VOM (Index 3, Position 1 = O)
            '3-1': [1, 1], // O -> Position 1 in VON
            // n -> 6. Buchstabe von GREIFNSON = Position 5 in GREIFN (Index 1, Position 5 = N)
            '1-5': [1, 2], // N -> Position 2 in VON
            
            // GRIMMELSHAUSEN
            '1-0': [2, 0], // g -> 1. Buchstabe von GREIFN (G)
            '1-1': [2, 1], // r -> 2. Buchstabe von GREIFN (R) - alternativ zu HIRSCHFELT, da R bereits für CHRISTOFFEL verwendet
            '4-1': [2, 2], // i -> 2. Buchstabe von HIRSCHFELT (I) - da GREIFN I bereits für CHRISTOFFEL verwendet
            '3-2': [2, 3], // m -> 3. Buchstabe von VOM (M)
            '0-2': [2, 4], // m -> 3. Buchstabe von SAMUEL (M)
            '1-2': [2, 5], // e -> 3. Buchstabe von GREIFN (E)
            '4-8': [2, 6], // l -> 9. Buchstabe von HIRSCHFELT (L)
            '2-0': [2, 7], // s -> 7. Buchstabe von GREIFNSON = Position 0 in SON (S)
            '4-5': [2, 8], // h -> 6. Buchstabe von HIRSCHFELT (H)
            '0-1': [2, 9], // a -> 2. Buchstabe von SAMUEL (A)
            '0-3': [2, 10], // u -> 4. Buchstabe von SAMUEL (U)
            '4-3': [2, 11], // s -> 4. Buchstabe von HIRSCHFELT (S)
            '4-7': [2, 12], // e -> 8. Buchstabe von HIRSCHFELT (E)
            '2-2': [2, 13], // n -> 9. Buchstabe von GREIFNSON = Position 2 in SON (N)
        };
        
        /**
         * Korrekte Buchstaben für jede Position in den Zielwörtern
         * Format: 'targetWordIndex-targetLetterIndex': 'Buchstabe'
         */
        const correctLetters = {
            // CHRISTOFFEL (Index 0)
            '0-0': 'C', '0-1': 'H', '0-2': 'R', '0-3': 'I', '0-4': 'S',
            '0-5': 'T', '0-6': 'O', '0-7': 'F', '0-8': 'F', '0-9': 'E', '0-10': 'L',
            // VON (Index 1)
            '1-0': 'V', '1-1': 'O', '1-2': 'N',
            // GRIMMELSHAUSEN (Index 2)
            '2-0': 'G', '2-1': 'R', '2-2': 'I', '2-3': 'M', '2-4': 'M',
            '2-5': 'E', '2-6': 'L', '2-7': 'S', '2-8': 'H', '2-9': 'A',
            '2-10': 'U', '2-11': 'S', '2-12': 'E', '2-13': 'N'
        };
        
        // ============================================================================
        // SPIELZUSTAND
        // ============================================================================
        
        /** Array aller erstellten Buchstaben-Elemente */
        let letters = [];
        
        /** Aktuell gezogener Buchstabe */
        let draggedLetter = null;
        
        /** Offset zwischen Maus/Touch-Position und Buchstaben-Mitte beim Drag-Start */
        let dragOffset = { x: 0, y: 0 };
        
        /** Platzhalter für den gezogenen Buchstaben */
        let letterPlaceholder = null;
        
        /** Gibt an, ob die Drop-Zone sichtbar ist */
        let dropZoneVisible = false;
        
        /** Timer für automatischen Reset bei Inaktivität */
        let resetTimer = null;
        
        // Gecachte DOM-Elemente
        let cachedElements = {
            dropZone: null,
            dropArrow: null,
            wordsContainer: null,
            slots: null
        };

        // ============================================================================
        // ANIMATIONS-KONTROLLE
        // ============================================================================
        
        /**
         * Konfiguration für alle Animationen und Darstellungsoptionen
         * Wird über das Burger-Menü anpassbar gemacht
         */
        let animationControls = {
            wobbleIntensityX: 2,
            wobbleIntensityY: 4.5,
            wobbleIntensityRot: 5.5,
            wobbleDurationMin: 8,
            wobbleDurationMax: 6.5,
            blurMax: 6,
            blurOpacityMin: 0.7,
            blurDurationMin: 2.5,
            blurDurationMax: 3.5,
            sourceLineHeight: 3.8,
            sourceLetterSpacing: -2,
            targetLineHeight: 0.7,
            targetLetterSpacing: 5,
            // Schriftgröße (einheitlich)
            letterSize: 3.8,
            // Neue Controls für Unterstriche
            underlineThickness: 1,
            underlineSpacing: 0,
            // Pfeil-Größe und vertikale Position (0 = -12rem, 100 = -6rem; 80 = -7.2rem)
            arrowSize: 5.8,
            arrowPosY: 80,
            // Gewinn-Bild: vertikale Position (0–100 %) und Größe (75–175 %, Standard 110 %)
            winImagePosY: 55,
            winImageScale: 110,
            // Container: vertikale Position (margin-top in rem)
            containerMarginTop: -2,
            // Hintergrundfarbe (Hex)
            backgroundColor: '#006449'
        };

        // ============================================================================
        // INITIALISIERUNG
        // ============================================================================
        
        /**
         * Initialisiert das gesamte Spiel
         * Wird beim Laden der Seite aufgerufen
         * @returns {void}
         */
        function initGame() {
            setupBurgerMenu();
            setupControls();
            updateTextSpacing();
            updateTextSizes();
            updateUnderlines();
            updateArrowSize();
            updateArrowPosition();
            updateWinImageStyle();
            updateContainerPosition();
            updateBackgroundColor();
            // Anzeige-Werte aktualisieren
            updateDisplayValues();
            createLetters();
            setupDropZone();
            setupEventListeners();
            resetInactivityTimer();
        }
        
        /**
         * Aktualisiert alle Anzeige-Werte im Kontroll-Panel
         * @returns {void}
         */
        function updateDisplayValues() {
            document.getElementById('source-line-height-value').textContent = animationControls.sourceLineHeight + 'rem';
            document.getElementById('source-letter-spacing-value').textContent = animationControls.sourceLetterSpacing + 'px';
            document.getElementById('target-line-height-value').textContent = animationControls.targetLineHeight + 'rem';
            document.getElementById('target-letter-spacing-value').textContent = animationControls.targetLetterSpacing + 'px';
            document.getElementById('letter-size-value').textContent = animationControls.letterSize + 'rem';
            document.getElementById('underline-thickness-value').textContent = animationControls.underlineThickness + 'px';
            document.getElementById('underline-spacing-value').textContent = animationControls.underlineSpacing + 'rem';
            document.getElementById('arrow-size-value').textContent = animationControls.arrowSize + 'rem';
            document.getElementById('win-image-pos-y-value').textContent = animationControls.winImagePosY + '%';
            document.getElementById('win-image-scale-value').textContent = animationControls.winImageScale + '%';
            document.getElementById('container-margin-top-value').textContent = animationControls.containerMarginTop + 'rem';
            document.getElementById('bg-color-value').textContent = animationControls.backgroundColor;
            document.getElementById('bg-color').value = animationControls.backgroundColor;
        }

        // ============================================================================
        // UI-SETUP
        // ============================================================================
        
        /**
         * Richtet das Burger-Menü für das Ein-/Ausblenden des Kontroll-Panels ein
         * @returns {void}
         */
        function setupBurgerMenu() {
            const burgerMenu = document.getElementById('burger-menu');
            const controlsPanel = document.getElementById('controls-panel');
            
            burgerMenu.addEventListener('click', () => {
                burgerMenu.classList.toggle('active');
                controlsPanel.classList.toggle('visible');
            });
        }

        /**
         * Richtet alle Steuerelemente im Kontroll-Panel ein
         * Bindet Event-Listener für alle Slider und aktualisiert die Anzeigen
         * @returns {void}
         */
        function setupControls() {
            // Wobble-Animation Steuerelemente
            const wobbleIntensityX = document.getElementById('wobble-intensity-x');
            const wobbleIntensityY = document.getElementById('wobble-intensity-y');
            const wobbleIntensityRot = document.getElementById('wobble-intensity-rot');
            const wobbleDurationMin = document.getElementById('wobble-duration-min');
            const wobbleDurationMax = document.getElementById('wobble-duration-max');

            // Unschärfe-Steuerelemente
            const blurMax = document.getElementById('blur-max');
            const blurOpacityMin = document.getElementById('blur-opacity-min');
            const blurDurationMin = document.getElementById('blur-duration-min');
            const blurDurationMax = document.getElementById('blur-duration-max');

            // Wobble-Event-Listener
            wobbleIntensityX.addEventListener('input', (e) => {
                animationControls.wobbleIntensityX = parseFloat(e.target.value);
                document.getElementById('wobble-intensity-x-value').textContent = animationControls.wobbleIntensityX + 'px';
                updateAllLetterAnimations();
            });

            wobbleIntensityY.addEventListener('input', (e) => {
                animationControls.wobbleIntensityY = parseFloat(e.target.value);
                document.getElementById('wobble-intensity-y-value').textContent = animationControls.wobbleIntensityY + 'px';
                updateAllLetterAnimations();
            });

            wobbleIntensityRot.addEventListener('input', (e) => {
                animationControls.wobbleIntensityRot = parseFloat(e.target.value);
                document.getElementById('wobble-intensity-rot-value').textContent = animationControls.wobbleIntensityRot + 'deg';
                updateAllLetterAnimations();
            });

            wobbleDurationMin.addEventListener('input', (e) => {
                animationControls.wobbleDurationMin = parseFloat(e.target.value);
                document.getElementById('wobble-duration-min-value').textContent = animationControls.wobbleDurationMin + 's';
                updateAllLetterAnimations();
            });

            wobbleDurationMax.addEventListener('input', (e) => {
                animationControls.wobbleDurationMax = parseFloat(e.target.value);
                document.getElementById('wobble-duration-max-value').textContent = animationControls.wobbleDurationMax + 's';
                updateAllLetterAnimations();
            });

            // Unschärfe-Event-Listener
            blurMax.addEventListener('input', (e) => {
                animationControls.blurMax = parseFloat(e.target.value);
                document.getElementById('blur-max-value').textContent = animationControls.blurMax + 'px';
                updateAllLetterAnimations();
            });

            blurOpacityMin.addEventListener('input', (e) => {
                animationControls.blurOpacityMin = parseFloat(e.target.value);
                document.getElementById('blur-opacity-min-value').textContent = animationControls.blurOpacityMin.toFixed(1);
                updateAllLetterAnimations();
            });

            blurDurationMin.addEventListener('input', (e) => {
                animationControls.blurDurationMin = parseFloat(e.target.value);
                document.getElementById('blur-duration-min-value').textContent = animationControls.blurDurationMin + 's';
                updateAllLetterAnimations();
            });

            blurDurationMax.addEventListener('input', (e) => {
                animationControls.blurDurationMax = parseFloat(e.target.value);
                document.getElementById('blur-duration-max-value').textContent = animationControls.blurDurationMax + 's';
                updateAllLetterAnimations();
            });

            // Text-Abstands-Steuerelemente
            const sourceLineHeight = document.getElementById('source-line-height');
            const sourceLetterSpacing = document.getElementById('source-letter-spacing');
            const targetLineHeight = document.getElementById('target-line-height');
            const targetLetterSpacing = document.getElementById('target-letter-spacing');

            sourceLineHeight.addEventListener('input', (e) => {
                animationControls.sourceLineHeight = parseFloat(e.target.value);
                document.getElementById('source-line-height-value').textContent = animationControls.sourceLineHeight + 'rem';
                updateTextSpacing();
            });

            sourceLetterSpacing.addEventListener('input', (e) => {
                animationControls.sourceLetterSpacing = parseFloat(e.target.value);
                document.getElementById('source-letter-spacing-value').textContent = animationControls.sourceLetterSpacing + 'px';
                updateTextSpacing();
            });

            targetLineHeight.addEventListener('input', (e) => {
                animationControls.targetLineHeight = parseFloat(e.target.value);
                document.getElementById('target-line-height-value').textContent = animationControls.targetLineHeight + 'rem';
                updateTextSpacing();
            });

            targetLetterSpacing.addEventListener('input', (e) => {
                animationControls.targetLetterSpacing = parseFloat(e.target.value);
                document.getElementById('target-letter-spacing-value').textContent = animationControls.targetLetterSpacing + 'px';
                updateTextSpacing();
            });

            // Schriftgrößen-Control (einheitlich)
            const letterSize = document.getElementById('letter-size');
            letterSize.addEventListener('input', (e) => {
                animationControls.letterSize = parseFloat(e.target.value);
                document.getElementById('letter-size-value').textContent = animationControls.letterSize + 'rem';
                updateTextSizes();
            });

            // Unterstriche-Controls
            const underlineThickness = document.getElementById('underline-thickness');
            const underlineSpacing = document.getElementById('underline-spacing');

            underlineThickness.addEventListener('input', (e) => {
                animationControls.underlineThickness = parseFloat(e.target.value);
                document.getElementById('underline-thickness-value').textContent = animationControls.underlineThickness + 'px';
                updateUnderlines();
            });

            underlineSpacing.addEventListener('input', (e) => {
                animationControls.underlineSpacing = parseFloat(e.target.value);
                document.getElementById('underline-spacing-value').textContent = animationControls.underlineSpacing + 'rem';
                updateUnderlines();
            });

            // Pfeil-Größen- und Positions-Controls
            const arrowSize = document.getElementById('arrow-size');
            arrowSize.addEventListener('input', (e) => {
                animationControls.arrowSize = parseFloat(e.target.value);
                document.getElementById('arrow-size-value').textContent = animationControls.arrowSize + 'rem';
                updateArrowSize();
            });
            const arrowPosY = document.getElementById('arrow-pos-y');
            arrowPosY.addEventListener('input', (e) => {
                animationControls.arrowPosY = parseInt(e.target.value, 10);
                document.getElementById('arrow-pos-y-value').textContent = arrowPosYToRem(animationControls.arrowPosY) + 'rem';
                updateArrowPosition();
            });

            // Gewinn-Bild: vertikale Position und Größe
            const winImagePosY = document.getElementById('win-image-pos-y');
            const winImageScale = document.getElementById('win-image-scale');
            winImagePosY.addEventListener('input', (e) => {
                animationControls.winImagePosY = parseInt(e.target.value, 10);
                document.getElementById('win-image-pos-y-value').textContent = animationControls.winImagePosY + '%';
                updateWinImageStyle();
            });
            winImageScale.addEventListener('input', (e) => {
                animationControls.winImageScale = parseInt(e.target.value, 10);
                document.getElementById('win-image-scale-value').textContent = animationControls.winImageScale + '%';
                updateWinImageStyle();
            });

            // Container: vertikale Position
            const containerMarginTop = document.getElementById('container-margin-top');
            containerMarginTop.addEventListener('input', (e) => {
                animationControls.containerMarginTop = parseFloat(e.target.value);
                document.getElementById('container-margin-top-value').textContent = animationControls.containerMarginTop + 'rem';
                updateContainerPosition();
            });

            // Hintergrundfarbe
            const bgColor = document.getElementById('bg-color');
            bgColor.addEventListener('input', (e) => {
                animationControls.backgroundColor = e.target.value;
                document.getElementById('bg-color-value').textContent = animationControls.backgroundColor;
                updateBackgroundColor();
            });

            // Debug: Gewinn-Event-Button
            const triggerWinButton = document.getElementById('trigger-win-button');
            triggerWinButton.addEventListener('click', () => {
                const event = new CustomEvent('anagramSolved', {
                    detail: { solution: targetSolution },
                    bubbles: true
                });
                document.dispatchEvent(event);
            });
        }

        // ============================================================================
        // UPDATE-FUNKTIONEN
        // ============================================================================
        
        /**
         * Aktualisiert die Text-Abstände (Zeilen- und Zeichenabstände) für Ausgangs- und Zieltext
         * @returns {void}
         */
        function updateTextSpacing() {
            document.documentElement.style.setProperty('--source-line-height', `${animationControls.sourceLineHeight}rem`);
            document.documentElement.style.setProperty('--source-letter-spacing', `${animationControls.sourceLetterSpacing}px`);
            document.documentElement.style.setProperty('--target-line-height', `${animationControls.targetLineHeight}rem`);
            document.documentElement.style.setProperty('--target-letter-spacing', `${animationControls.targetLetterSpacing}px`);
        }

        /**
         * Aktualisiert die Schriftgröße (einheitlich) und die Slot-Größen
         * @returns {void}
         */
        function updateTextSizes() {
            document.documentElement.style.setProperty('--letter-size', `${animationControls.letterSize}rem`);

            // Slot-Größen dynamisch basierend auf Schriftgröße berechnen
            const slotWidth = animationControls.letterSize;
            const slotHeight = animationControls.letterSize * 1.3;

            document.documentElement.style.setProperty('--slot-width', `${slotWidth}rem`);
            document.documentElement.style.setProperty('--slot-height', `${slotHeight}rem`);
        }

        /**
         * Aktualisiert die Stile der Unterstriche (Dicke und Abstand)
         * @returns {void}
         */
        function updateUnderlines() {
            document.documentElement.style.setProperty('--underline-thickness', `${animationControls.underlineThickness}px`);
            document.documentElement.style.setProperty('--underline-spacing', `${animationControls.underlineSpacing}rem`);
        }

        /**
         * Aktualisiert die Größe des Pfeils
         * @returns {void}
         */
        function updateArrowSize() {
            document.documentElement.style.setProperty('--arrow-size', `${animationControls.arrowSize}rem`);
        }

        /**
         * Slider 0–100 auf rem abbilden (0 = -12rem, 100 = -6rem, Standard 50 = -9rem)
         * @param {number} value - Sliderwert 0–100
         * @returns {number} - Position in rem
         */
        function arrowPosYToRem(value) {
            return -12 + (value / 100) * 6;
        }

        /**
         * Aktualisiert die vertikale Position des Pfeils (CSS-Variable)
         * @returns {void}
         */
        function updateArrowPosition() {
            const rem = arrowPosYToRem(animationControls.arrowPosY);
            document.documentElement.style.setProperty('--arrow-pos-y', `${rem}rem`);
        }

        /**
         * Aktualisiert die vertikale Position des Spiel-Containers (margin-top)
         * @returns {void}
         */
        function updateContainerPosition() {
            document.documentElement.style.setProperty('--game-container-margin-top', `${animationControls.containerMarginTop}rem`);
        }

        /**
         * Aktualisiert die Hintergrundfarbe (CSS-Variable)
         * @returns {void}
         */
        function updateBackgroundColor() {
            document.documentElement.style.setProperty('--game-bg-color', animationControls.backgroundColor);
        }

        /**
         * Aktualisiert Position und Größe des Gewinn-Bildes (CSS-Variablen)
         * @returns {void}
         */
        function updateWinImageStyle() {
            document.documentElement.style.setProperty('--win-image-translate-y', String(animationControls.winImagePosY - 50));
            document.documentElement.style.setProperty('--win-image-scale', animationControls.winImageScale / 100);
        }

        /**
         * Aktualisiert alle Buchstaben-Animationen mit den aktuellen Kontrollwerten
         * Setzt CSS-Variablen für Wobble- und Blur-Animationen und aktualisiert jedes Buchstaben-Element
         * @returns {void}
         */
        function updateAllLetterAnimations() {
            // CSS-Root-Variablen für Wobble und Blur aktualisieren
            document.documentElement.style.setProperty('--wobble-intensity-x', `${animationControls.wobbleIntensityX}px`);
            document.documentElement.style.setProperty('--wobble-intensity-y', `${animationControls.wobbleIntensityY}px`);
            document.documentElement.style.setProperty('--wobble-intensity-rot', `${animationControls.wobbleIntensityRot}deg`);
            document.documentElement.style.setProperty('--blur-max', `${animationControls.blurMax}px`);
            document.documentElement.style.setProperty('--blur-opacity-min', animationControls.blurOpacityMin);

            // Jeden Buchstaben aktualisieren
            letters.forEach(letter => {
                if (!letter.classList.contains('dragging') && letter.dataset.inSlot !== 'true') {
                    // Individuelle Timing-Werte neu berechnen oder beibehalten
                    const wobbleDelay = letter.style.getPropertyValue('--wobble-delay') || ((Math.random() * 8) - 4) + 's';
                    const blurDelay = letter.style.getPropertyValue('--blur-delay') || ((Math.random() * 6) - 3) + 's';
                    
                    // Zufällige Dauer innerhalb des Bereichs
                    const wobbleDuration = animationControls.wobbleDurationMin + 
                        Math.random() * (animationControls.wobbleDurationMax - animationControls.wobbleDurationMin);
                    const blurDuration = animationControls.blurDurationMin + 
                        Math.random() * (animationControls.blurDurationMax - animationControls.blurDurationMin);

                    letter.style.setProperty('--wobble-delay', wobbleDelay);
                    letter.style.setProperty('--blur-delay', blurDelay);
                    letter.style.setProperty('--wobble-duration', `${wobbleDuration}s`);
                    letter.style.setProperty('--blur-duration', `${blurDuration}s`);

                    // Animation erneut anwenden
                    letter.style.animation = `wobble var(--wobble-duration, 4s) ease-in-out infinite, blurPulse var(--blur-duration, 3s) ease-in-out infinite`;
                    letter.style.animationDelay = `var(--wobble-delay, 0s), var(--blur-delay, 0s)`;
                }
            });
        }

        // ============================================================================
        // BUCHSTABEN-ERSTELLUNG
        // ============================================================================
        
        /**
         * Erstellt alle Buchstaben-Elemente mit zufälligen Rotationen und Offsets
         * Markiert Buchstaben basierend auf ihrer Zielwort-Zuordnung für unterschiedliche Größen
         * @returns {void}
         */
        function createLetters() {
            const wordContainers = {
                'word-samuel': { word: 'SAMUEL', index: 0 },
                'word-greifn': { word: 'GREIFN', index: 1 },
                'word-son': { word: 'SON', index: 2 },
                'word-vom': { word: 'VOM', index: 3 },
                'word-hirschfelt': { word: 'HIRSCHFELT', index: 4 }
            };

            letters = [];

            Object.keys(wordContainers).forEach(containerId => {
                const container = document.getElementById(containerId);
                const wordData = wordContainers[containerId];
                const word = wordData.word;
                const wordIndex = wordData.index;
                
                word.split('').forEach((char, index) => {
                    const letter = document.createElement('span');
                    letter.className = 'letter';
                    letter.innerHTML = getLetterSVG(char);
                    letter.dataset.letter = char;
                    letter.dataset.originalWord = word;
                    letter.dataset.originalWordIndex = wordIndex;
                    letter.dataset.letterIndex = index;
                    
                    // Markiere Buchstaben basierend auf ihrer Zielwort-Zuordnung
                    const mappingKey = `${wordIndex}-${index}`;
                    const mapping = letterMapping[mappingKey];
                    if (mapping) {
                        const targetWordIndex = mapping[0];
                        if (targetWordIndex === 0) { // CHRISTOFFEL
                            letter.dataset.forChristoffel = 'true';
                        } else if (targetWordIndex === 1) { // VON
                            letter.dataset.forVon = 'true';
                        } else if (targetWordIndex === 2) { // GRIMMELSHAUSEN
                            letter.dataset.forGrimmelshausen = 'true';
                        }
                    }
                    
                    // Zufällige Rotation zwischen -15° und +15° (als CSS-Variable gespeichert)
                    const rotation = (Math.random() * 30) - 15;
                    // Zufälliger Offset zwischen -5px und +5px
                    const offsetX = (Math.random() * 10) - 5;
                    const offsetY = (Math.random() * 10) - 5;
                    
                    // Basis-Transform-Werte speichern
                    letter.dataset.baseRotation = rotation;
                    letter.dataset.baseOffsetX = offsetX;
                    letter.dataset.baseOffsetY = offsetY;
                    
                    // Basis-Transform anwenden (wird mit Animation kombiniert)
                    letter.style.setProperty('--base-rotation', `${rotation}deg`);
                    letter.style.setProperty('--base-offset-x', `${offsetX}px`);
                    letter.style.setProperty('--base-offset-y', `${offsetY}px`);
                    
                    // Individuelles Animation-Timing für jeden Buchstaben
                    // Zufälliger Wobble-Delay zwischen -4s und +4s (erlaubt Start in jeder Phase)
                    const wobbleDelay = (Math.random() * 8) - 4;
                    // Zufälliger Blur-Delay zwischen -3s und +3s (erlaubt Start in jeder Phase)
                    const blurDelay = (Math.random() * 6) - 3;
                    // Zufällige Wobble-Dauer innerhalb des Kontrollbereichs
                    const wobbleDuration = animationControls.wobbleDurationMin + 
                        Math.random() * (animationControls.wobbleDurationMax - animationControls.wobbleDurationMin);
                    // Zufällige Blur-Dauer innerhalb des Kontrollbereichs
                    const blurDuration = animationControls.blurDurationMin + 
                        Math.random() * (animationControls.blurDurationMax - animationControls.blurDurationMin);
                    
                    letter.style.setProperty('--wobble-delay', `${wobbleDelay}s`);
                    letter.style.setProperty('--blur-delay', `${blurDelay}s`);
                    letter.style.setProperty('--wobble-duration', `${wobbleDuration}s`);
                    letter.style.setProperty('--blur-duration', `${blurDuration}s`);
                    
                    // Individuelles Animation-Timing anwenden
                    letter.style.animation = `wobble var(--wobble-duration, 4s) ease-in-out infinite, blurPulse var(--blur-duration, 3s) ease-in-out infinite`;
                    letter.style.animationDelay = `var(--wobble-delay, 0s), var(--blur-delay, 0s)`;
                    
                    // Initialen Transform mit Basis-Werten anwenden
                    updateLetterBaseTransform(letter);
                    
                    container.appendChild(letter);
                    letters.push(letter);
                });
            });
        }

        /**
         * Richtet die Drop-Zone mit Unterstrichen für die Lösungswörter ein
         * Erstellt für jedes Wort eine Zeile mit Slots für jeden Buchstaben
         * @returns {void}
         */
        function setupDropZone() {
            cachedElements.dropZone = document.getElementById('drop-zone');
            const words = targetSolution.split(' ');
            let slotIndex = 0;
            
            words.forEach((word, wordIndex) => {
                // Container für jedes Wort erstellen
                const wordRow = document.createElement('div');
                wordRow.className = 'word-row-slots';
                wordRow.dataset.wordIndex = wordIndex;
                
                // Slots für jeden Buchstaben im Wort hinzufügen
                for (let i = 0; i < word.length; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'drop-slot';
                    slot.dataset.slotIndex = slotIndex;
                    slot.dataset.letterIndex = i;
                    slot.dataset.wordIndex = wordIndex;
                    wordRow.appendChild(slot);
                    slotIndex++;
                }
                
                cachedElements.dropZone.appendChild(wordRow);
            });
            // Slots nach Erstellung cachen
            cachedElements.slots = null; // Wird bei Bedarf neu geladen
        }

        // ============================================================================
        // EVENT-HANDLER SETUP
        // ============================================================================
        
        /**
         * Richtet alle Event-Listener für Drag & Drop und Interaktionen ein
         * @returns {void}
         */
        function setupEventListeners() {
            letters.forEach(letter => {
                // Touch-Events
                letter.addEventListener('touchstart', handleDragStart, { passive: false });
                letter.addEventListener('touchmove', handleDragMove, { passive: false });
                letter.addEventListener('touchend', handleDragEnd, { passive: false });
                
                // Mouse-Events
                letter.addEventListener('mousedown', handleDragStart);
                letter.addEventListener('mousemove', handleDragMove);
                letter.addEventListener('mouseup', handleDragEnd);
            });

            // Globale Mouse-Events für Drag
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);

            // Timer bei jeder Interaktion zurücksetzen
            document.addEventListener('touchstart', resetInactivityTimer, { passive: true });
            document.addEventListener('mousedown', resetInactivityTimer);
            document.addEventListener('keydown', resetInactivityTimer);

            // Mobil: Textauswahl (blaue Hervorhebung) und Kontextmenü verhindern, Drag bleibt unberührt
            document.addEventListener('selectstart', (e) => e.preventDefault());
            document.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        // ============================================================================
        // HILFSFUNKTIONEN
        // ============================================================================
        
        /**
         * Setzt alle Position-Styles eines Elements zurück
         * @param {HTMLElement} element - Das Element
         * @returns {void}
         */
        function resetPositionStyles(element) {
            element.style.position = '';
            element.style.left = '';
            element.style.top = '';
            element.style.right = '';
            element.style.bottom = '';
            element.style.transform = '';
            element.style.zIndex = '';
            element.style.margin = '';
            element.style.padding = '';
        }
        
        /**
         * Ermittelt die Client-Koordinaten aus einem Event (Touch oder Mouse)
         * @param {Event} e - Das Event
         * @returns {{x: number, y: number}} - Koordinaten
         */
        function getEventCoordinates(e) {
            if (e.touches && e.touches[0]) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            if (e.changedTouches && e.changedTouches[0]) {
                return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }
        
        /**
         * Ermittelt die Zentrumskoordinaten eines Elements
         * @param {HTMLElement} element - Das Element
         * @returns {{x: number, y: number}} - Zentrumskoordinaten
         */
        function getElementCenter(element) {
            const rect = element.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }
        
        /**
         * Parst einen Integer-Wert aus einem Dataset-Attribut mit Fallback
         * @param {HTMLElement} element - Das Element
         * @param {string} key - Der Dataset-Schlüssel
         * @param {number} fallback - Fallback-Wert (Standard: 0)
         * @returns {number} - Der geparste Wert
         */
        function getDatasetInt(element, key, fallback = 0) {
            return parseInt(element.dataset[key]) || fallback;
        }
        
        // ============================================================================
        // DRAG & DROP HANDLER
        // ============================================================================
        
        /**
         * Behandelt den Start des Drag-Vorgangs
         * @param {Event} e - Touch- oder Mouse-Event
         * @returns {void}
         */
        function handleDragStart(e) {
            e.preventDefault();
            resetInactivityTimer();
            
            const letter = e.target.closest('.letter');
            if (!letter || letter.classList.contains('dragging')) return;
            
            // Wenn bereits ein Buchstabe gezogen wird, diesen ignorieren
            if (draggedLetter && draggedLetter !== letter) return;

            draggedLetter = letter;
            letter.classList.add('dragging');

            // Touch/Mouse-Position ermitteln
            const coords = getEventCoordinates(e);
            const clientX = coords.x;
            const clientY = coords.y;

            // Animation stoppen und Transform zurücksetzen für sauberes Dragging
            letter.style.animation = 'none';
            letter.style.filter = 'blur(0px)';
            letter.style.opacity = '1';
            
            // Wenn Buchstabe in einem Slot ist, zuerst entfernen und Styles zurücksetzen
            const wasInSlot = letter.dataset.inSlot === 'true';
            if (wasInSlot) {
                const slot = letter.parentNode;
                if (slot && slot.classList.contains('drop-slot')) {
                    slot.classList.remove('filled');
                    slot.removeChild(letter);
                }
                letter.dataset.inSlot = 'false';
                
                // Alle Position-Styles vom Slot zurücksetzen, bevor feste Position gesetzt wird
                resetPositionStyles(letter);
                
                // Buchstaben temporär zum Body hinzufügen, damit er sichtbar ist beim Setzen der festen Position
                document.body.appendChild(letter);
                
                // Reflow erzwingen, um sicherzustellen, dass Styles zurückgesetzt sind
                void letter.offsetHeight;
            } else {
                // Wenn Buchstabe im words-container ist, müssen wir Container-Transform berücksichtigen
                // Aktuelle visuelle Position des Buchstabens ermitteln (inkl. Container-Transform)
                const center = getElementCenter(letter);
                
                // Offset vom Touch-Punkt zum Buchstaben-Zentrum berechnen
                dragOffset.x = clientX - center.x;
                dragOffset.y = clientY - center.y;
                
                // Platzhalter an der ursprünglichen Position erstellen
                const placeholder = document.createElement('span');
                placeholder.className = 'letter-placeholder';
                placeholder.dataset.placeholderFor = letter.dataset.letter;
                placeholder.dataset.originalWord = letter.dataset.originalWord;
                placeholder.dataset.letterIndex = letter.dataset.letterIndex;
                
                // Platzhalter an der ursprünglichen Position einfügen
                const letterIndex = getDatasetInt(letter, 'letterIndex');
                const existingLetters = letter.parentNode.querySelectorAll('.letter');
                
                // Korrekten Einfügepunkt finden
                let insertBefore = null;
                for (let i = 0; i < existingLetters.length; i++) {
                    const existingIndex = getDatasetInt(existingLetters[i], 'letterIndex');
                    if (existingIndex > letterIndex) {
                        insertBefore = existingLetters[i];
                        break;
                    }
                }
                
                if (insertBefore) {
                    letter.parentNode.insertBefore(placeholder, insertBefore);
                } else {
                    letter.parentNode.appendChild(placeholder);
                }
                
                letterPlaceholder = placeholder;
                
                // Buchstaben temporär vom Container entfernen, um Transform-Probleme zu vermeiden
                if (letter.parentNode) {
                    letter.parentNode.removeChild(letter);
                }
                document.body.appendChild(letter);
                
                // Transform zurücksetzen, um saubere Positionierung sicherzustellen
                letter.style.transform = '';
                
                // Reflow erzwingen
                void letter.offsetHeight;
            }
            
            // Mit translate(-50%, -50%) zentrieren wir auf dem Touch-Punkt
            // Aber wir müssen den Offset berücksichtigen, wenn der Buchstabe im Container war
            if (!wasInSlot) {
                // Position anpassen, um Offset zu berücksichtigen
                updateLetterPosition(letter, clientX - dragOffset.x, clientY - dragOffset.y);
            } else {
                // Für Buchstaben aus Slots ist kein Offset nötig
                dragOffset.x = 0;
                dragOffset.y = 0;
                updateLetterPosition(letter, clientX, clientY);
            }

            // Drop-Zone beim ersten Drag anzeigen
            if (!dropZoneVisible) {
                showDropZone();
                slideUpNonDraggedLetters();
                showDropArrow();
            }
        }

        /**
         * Behandelt die Bewegung während des Drag-Vorgangs
         * @param {Event} e - Touch- oder Mouse-Event
         * @returns {void}
         */
        function handleDragMove(e) {
            if (!draggedLetter) return;
            e.preventDefault();

            const coords = getEventCoordinates(e);
            updateLetterPosition(draggedLetter, coords.x, coords.y);
        }

        /**
         * Behandelt das Ende des Drag-Vorgangs
         * Validiert die Position und platziert den Buchstaben oder setzt ihn zurück
         * @param {Event} e - Touch- oder Mouse-Event
         * @returns {void}
         */
        function handleDragEnd(e) {
            if (!draggedLetter) return;
            e.preventDefault();

            const letter = draggedLetter;
            letter.classList.remove('dragging');

            // Prüfe, ob auf einem Slot abgelegt wurde
            const coords = getEventCoordinates(e);
            const dropSlot = getDropSlotAtPosition(coords.x, coords.y);
            
            // Speichere die aktuelle Cursor-Position für die Animation
            const animationStartX = coords.x;
            const animationStartY = coords.y;
            
            // Feste Position-Styles zurücksetzen, bevor platziert oder zurückgesetzt wird
            resetPositionStyles(letter);
            
            // Reflow erzwingen, um sicherzustellen, dass Styles zurückgesetzt sind
            void letter.offsetHeight;
            
            if (dropSlot) {
                const existingLetter = dropSlot.querySelector('.letter');
                
                // Wenn Slot bereits belegt ist, prüfe ob es derselbe Buchstabe ist
                if (existingLetter && existingLetter !== letter) {
                    // Slot ist belegt - prüfe ob der Buchstabe getauscht werden kann
                    const targetWordIndex = getDatasetInt(dropSlot, 'wordIndex');
                    const targetLetterIndex = getDatasetInt(dropSlot, 'letterIndex');
                    const correctLetterKey = `${targetWordIndex}-${targetLetterIndex}`;
                    const expectedLetter = correctLetters[correctLetterKey];
                    
                    // Wenn beide Buchstaben identisch sind und zum gleichen Zielwort gehören, erlaube Tausch
                    if (letter.dataset.letter === expectedLetter && existingLetter.dataset.letter === expectedLetter) {
                        // Entferne den alten Buchstaben und platziere den neuen
                        returnLetterToOriginalPositionWithAnimation(existingLetter);
                        // Warte kurz, dann platziere den neuen Buchstaben
                        setTimeout(() => {
                            if (isValidSlotForLetter(letter, dropSlot)) {
                                placeLetterInSlot(letter, dropSlot);
                            }
                        }, SWAP_DELAY);
                    } else {
                        // Falscher Buchstabe - zurück zur ursprünglichen Position von Cursor-Position
                        returnLetterToOriginalPositionWithAnimation(letter, animationStartX, animationStartY);
                    }
                } else if (!existingLetter) {
                    // Slot ist frei - prüfe ob Buchstabe hier platziert werden kann
                    if (isValidSlotForLetter(letter, dropSlot)) {
                        // Gültiger Slot - Buchstabe platzieren
                        placeLetterInSlot(letter, dropSlot);
                    } else {
                        // Falscher Slot - zurück zur ursprünglichen Position mit Animation von Cursor-Position
                        returnLetterToOriginalPositionWithAnimation(letter, animationStartX, animationStartY);
                    }
                } else {
                    // Gleicher Buchstabe bereits im Slot - nichts tun, sanft zurück von Cursor-Position
                    returnLetterToOriginalPositionWithAnimation(letter, animationStartX, animationStartY);
                }
            } else {
                // Kein Slot - sanft zurück zur Ursprungsposition von Cursor-Position
                returnLetterToOriginalPositionWithAnimation(letter, animationStartX, animationStartY);
            }

            draggedLetter = null;
            checkSolution();
        }
        
        // ============================================================================
        // DRAG & DROP HILFSFUNKTIONEN
        // ============================================================================
        
        /**
         * Setzt einen Buchstaben mit sanfter Animation an seine ursprüngliche Position zurück
         * @param {HTMLElement} letter - Das Buchstaben-Element
         * @param {number|null} startX - Start-X-Position (optional, wird sonst aus getBoundingClientRect ermittelt)
         * @param {number|null} startY - Start-Y-Position (optional, wird sonst aus getBoundingClientRect ermittelt)
         * @returns {void}
         */
        function returnLetterToOriginalPositionWithAnimation(letter, startX = null, startY = null) {
            // Aktuelle Position ermitteln - entweder übergeben oder aus getBoundingClientRect
            let currentX, currentY;
            if (startX !== null && startY !== null) {
                // Verwende übergebene Position (Cursor-Position)
                currentX = startX;
                currentY = startY;
            } else {
                // Fallback: Position aus getBoundingClientRect
                const center = getElementCenter(letter);
                currentX = center.x;
                currentY = center.y;
            }
            
            // Feste Position für Animation setzen
            letter.style.position = 'fixed';
            letter.style.left = currentX + 'px';
            letter.style.top = currentY + 'px';
            letter.style.transform = 'translate(-50%, -50%)';
            letter.style.zIndex = Z_INDEX_ANIMATION;
            letter.style.transition = `left ${ANIMATION_DURATION}ms ease-out, top ${ANIMATION_DURATION}ms ease-out`;
            
            // Zielposition berechnen - zuerst prüfen ob Platzhalter vorhanden ist
            let targetX, targetY;
            const originalWord = letter.dataset.originalWord;
            const wordContainerId = `word-${originalWord.toLowerCase()}`;
            const wordContainer = document.getElementById(wordContainerId);
            
            if (letterPlaceholder && letterPlaceholder.parentNode === wordContainer) {
                // Platzhalter vorhanden - verwende dessen Position
                const center = getElementCenter(letterPlaceholder);
                targetX = center.x;
                targetY = center.y;
            } else if (wordContainer) {
                // Kein Platzhalter - verwende Container-Mitte als Fallback
                const center = getElementCenter(wordContainer);
                targetX = center.x;
                targetY = center.y;
            } else {
                // Kein Container gefunden - direkt zurück
                returnLetterToOriginalPosition(letter);
                return;
            }
            
            // Zurück animieren
            setTimeout(() => {
                letter.style.left = targetX + 'px';
                letter.style.top = targetY + 'px';
                
                // Nach Animation zurück zum Container
                setTimeout(() => {
                    returnLetterToOriginalPosition(letter);
                }, ANIMATION_DURATION);
            }, REFLOW_DELAY);
        }

        /**
         * Aktualisiert die Position eines Buchstaben während des Drag-Vorgangs
         * @param {HTMLElement} letter - Das Buchstaben-Element
         * @param {number} x - X-Koordinate
         * @param {number} y - Y-Koordinate
         * @returns {void}
         */
        function updateLetterPosition(letter, x, y) {
            // Position-Styles direkt setzen - stellt sicher, dass Hitbox mit visueller Position übereinstimmt
            letter.style.position = 'fixed';
            letter.style.left = x + 'px';
            letter.style.top = y + 'px';
            letter.style.right = 'auto';
            letter.style.bottom = 'auto';
            letter.style.transform = 'translate(-50%, -50%)';
            letter.style.zIndex = Z_INDEX_DRAGGING;
        }

        /**
         * Findet den Drop-Slot an der angegebenen Position
         * @param {number} x - X-Koordinate
         * @param {number} y - Y-Koordinate
         * @returns {HTMLElement|null} - Der gefundene Slot oder null
         */
        function getDropSlotAtPosition(x, y) {
            if (!cachedElements.slots) {
                cachedElements.slots = document.querySelectorAll('.drop-slot');
            }
            for (let slot of cachedElements.slots) {
                const rect = slot.getBoundingClientRect();
                if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                    return slot;
                }
            }
            return null;
        }

        // ============================================================================
        // VALIDIERUNG
        // ============================================================================
        
        /**
         * Findet alle möglichen Quellen für einen bestimmten Buchstaben an einer bestimmten Position im Zielwort
         * Berücksichtigt, dass identische Buchstaben von verschiedenen Quellen kommen können
         * @param {number} targetWordIndex - Index des Zielworts
         * @param {number} targetLetterIndex - Index des Buchstabens im Zielwort
         * @param {string} letterChar - Der Buchstabe
         * @returns {Array} - Array von Objekten mit sourceWordIndex und sourceLetterIndex
         */
        function findPossibleSourcesForTargetPosition(targetWordIndex, targetLetterIndex, letterChar) {
            const possibleSources = [];
            
            // Durchsuche alle Mappings, um Quellen zu finden, die zu dieser exakten Position führen
            for (const [sourceKey, targetMapping] of Object.entries(letterMapping)) {
                if (targetMapping[0] === targetWordIndex && targetMapping[1] === targetLetterIndex) {
                    const [sourceWordIndex, sourceLetterIndex] = sourceKey.split('-').map(Number);
                    const sourceWord = words[sourceWordIndex];
                    const sourceChar = sourceWord[sourceLetterIndex];
                    
                    if (sourceChar === letterChar) {
                        possibleSources.push({ sourceWordIndex, sourceLetterIndex });
                    }
                }
            }
            
            // Finde alle Positionen im Zielwort, die den gleichen Buchstaben benötigen
            // (für Tausch-Möglichkeit identischer Buchstaben)
            const allSlotsForWord = document.querySelectorAll(`.word-row-slots[data-word-index="${targetWordIndex}"] .drop-slot`);
            const positionsWithSameLetter = [];
            
            for (let otherSlot of allSlotsForWord) {
                const otherSlotIndex = getDatasetInt(otherSlot, 'letterIndex');
                const otherSlotKey = `${targetWordIndex}-${otherSlotIndex}`;
                const otherExpectedLetter = correctLetters[otherSlotKey];
                
                if (otherExpectedLetter === letterChar) {
                    positionsWithSameLetter.push(otherSlotIndex);
                }
            }
            
            // Finde alle Quellen, die zu einer dieser Positionen führen
            for (const [sourceKey, targetMapping] of Object.entries(letterMapping)) {
                if (targetMapping[0] === targetWordIndex && positionsWithSameLetter.includes(targetMapping[1])) {
                    const [sourceWordIndex, sourceLetterIndex] = sourceKey.split('-').map(Number);
                    const sourceWord = words[sourceWordIndex];
                    const sourceChar = sourceWord[sourceLetterIndex];
                    
                    if (sourceChar === letterChar) {
                        // Prüfe, ob diese Quelle noch nicht in der Liste ist
                        const exists = possibleSources.some(s => 
                            s.sourceWordIndex === sourceWordIndex && s.sourceLetterIndex === sourceLetterIndex
                        );
                        if (!exists) {
                            possibleSources.push({ sourceWordIndex, sourceLetterIndex });
                        }
                    }
                }
            }
            
            return possibleSources;
        }

        /**
         * Prüft, ob ein Buchstabe an einer gültigen Position im Zielwort platziert werden kann
         * Berücksichtigt:
         * - Identische Buchstaben im gleichen Wort können beliebig getauscht werden
         * - Ein Buchstabe kann von verschiedenen Quellen kommen
         * @param {HTMLElement} letter - Das Buchstaben-Element
         * @param {HTMLElement} slot - Der Drop-Slot
         * @returns {boolean} - true wenn gültig, sonst false
         */
        function isValidSlotForLetter(letter, slot) {
            const sourceWordIndex = getDatasetInt(letter, 'originalWordIndex');
            const sourceLetterIndex = getDatasetInt(letter, 'letterIndex');
            const targetWordIndex = getDatasetInt(slot, 'wordIndex');
            const targetLetterIndex = getDatasetInt(slot, 'letterIndex');
            const letterChar = letter.dataset.letter;
            
            // Prüfe, welcher Buchstabe an dieser Position erwartet wird
            const correctLetterKey = `${targetWordIndex}-${targetLetterIndex}`;
            const expectedLetter = correctLetters[correctLetterKey];
            
            // Wenn der Buchstabe nicht passt, ist es ungültig
            if (expectedLetter !== letterChar) {
                return false;
            }
            
            // Prüfe, ob es irgendein Mapping gibt, das diesen Buchstaben zu diesem Zielwort zuordnet
            // (gleiche Buchstaben innerhalb eines Zielworts sind austauschbar)
            let hasValidMapping = false;
            
            // Durchsuche alle Mappings, um zu prüfen, ob dieser Buchstabe zu diesem Zielwort gehört
            for (const [sourceKey, targetMapping] of Object.entries(letterMapping)) {
                if (targetMapping[0] === targetWordIndex) {
                    // Dieses Mapping führt zu unserem Zielwort
                    const [sourceWordIdx, sourceLetterIdx] = sourceKey.split('-').map(Number);
                    const sourceWord = words[sourceWordIdx];
                    const sourceChar = sourceWord[sourceLetterIdx];
                    
                    // Wenn der Buchstabe übereinstimmt, ist es ein gültiges Mapping
                    if (sourceChar === letterChar) {
                        hasValidMapping = true;
                        break;
                    }
                }
            }
            
            // Wenn kein gültiges Mapping gefunden wurde, ist es ungültig
            if (!hasValidMapping) {
                return false;
            }
            
            // Buchstabe stimmt und gehört zum richtigen Zielwort:
            // identische Buchstaben dürfen beliebig auf die passenden Slots verteilt werden
            return true;
        }

        /**
         * Platziert einen Buchstaben in einem Drop-Slot
         * @param {HTMLElement} letter - Das Buchstaben-Element
         * @param {HTMLElement} slot - Der Drop-Slot
         * @returns {void}
         */
        function placeLetterInSlot(letter, slot) {
            // Dragging-Klasse entfernen
            letter.classList.remove('dragging');
            
            // Platzhalter NICHT löschen - bleibt bestehen, wenn Buchstabe erfolgreich platziert wird
            
            // Von aktuellem Parent entfernen falls vorhanden
            if (letter.parentNode) {
                letter.parentNode.removeChild(letter);
            }
            
            // Alle Styles zurücksetzen
            letter.style.position = 'absolute';
            letter.style.left = '50%';
            letter.style.top = '0';
            letter.style.right = '';
            letter.style.bottom = '';
            letter.style.transform = 'translateX(-50%)';
            letter.style.zIndex = '1';
            letter.style.animation = 'none';
            letter.style.filter = 'blur(0px)';
            letter.style.opacity = '1';
            
            // Zum Slot hinzufügen
            slot.appendChild(letter);
            slot.classList.add('filled');
            letter.dataset.inSlot = 'true';
            letter.dataset.slotIndex = slot.dataset.slotIndex;
        }

        /**
         * Aktualisiert die Basis-Transform-Werte eines Buchstabens
         * @param {HTMLElement} letter - Das Buchstaben-Element
         * @returns {void}
         */
        function updateLetterBaseTransform(letter) {
            const rotation = letter.dataset.baseRotation || 0;
            const offsetX = letter.dataset.baseOffsetX || 0;
            const offsetY = letter.dataset.baseOffsetY || 0;
            
            letter.style.setProperty('--base-rotation', `${rotation}deg`);
            letter.style.setProperty('--base-offset-x', `${offsetX}px`);
            letter.style.setProperty('--base-offset-y', `${offsetY}px`);
        }

        /**
         * Setzt einen Buchstaben an seine ursprüngliche Position zurück
         * @param {HTMLElement} letter - Das Buchstaben-Element
         * @returns {void}
         */
        function returnLetterToOriginalPosition(letter) {
            const originalWord = letter.dataset.originalWord;
            // Korrekten Wort-Container finden - behandelt sowohl Groß- als auch Kleinschreibung
            const wordContainerId = `word-${originalWord.toLowerCase()}`;
            const wordContainer = document.getElementById(wordContainerId);
            
            if (wordContainer) {
                // Dragging-Klasse entfernen
                letter.classList.remove('dragging');
                
                // Von aktuellem Parent entfernen (könnte Drop-Slot oder anderer Wort-Container sein)
                if (letter.parentNode) {
                    letter.parentNode.removeChild(letter);
                }
                
                // Alle Position- und Transform-Styles vollständig zurücksetzen
                // Alle Inline-Styles entfernen, die die Positionierung beeinflussen könnten
                letter.style.position = '';
                letter.style.left = '';
                letter.style.top = '';
                letter.style.right = '';
                letter.style.bottom = '';
                letter.style.zIndex = '';
                letter.style.transform = '';
                letter.style.margin = '';
                letter.style.padding = '';
                
                // Reflow erzwingen, um sicherzustellen, dass Styles zurückgesetzt sind
                void letter.offsetHeight;
                
                // Basis-Transform-Werte wiederherstellen (CSS-Variablen für Animation)
                // Muss NACH dem Hinzufügen zum Container passieren, damit Hitbox korrekt positioniert ist
                
                    // Individuelle Animation wiederherstellen, falls noch nicht gesetzt
                    if (!letter.style.getPropertyValue('--wobble-delay')) {
                        const wobbleDelay = (Math.random() * 8) - 4;
                        const blurDelay = (Math.random() * 6) - 3;
                    const wobbleDuration = animationControls.wobbleDurationMin + 
                        Math.random() * (animationControls.wobbleDurationMax - animationControls.wobbleDurationMin);
                    const blurDuration = animationControls.blurDurationMin + 
                        Math.random() * (animationControls.blurDurationMax - animationControls.blurDurationMin);
                    
                    letter.style.setProperty('--wobble-delay', `${wobbleDelay}s`);
                    letter.style.setProperty('--blur-delay', `${blurDelay}s`);
                    letter.style.setProperty('--wobble-duration', `${wobbleDuration}s`);
                    letter.style.setProperty('--blur-duration', `${blurDuration}s`);
                    
                    letter.style.animation = `wobble var(--wobble-duration, 4s) ease-in-out infinite, blurPulse var(--blur-duration, 3s) ease-in-out infinite`;
                    letter.style.animationDelay = `var(--wobble-delay, 0s), var(--blur-delay, 0s)`;
                } else {
                    // Animation erneut aktivieren
                    letter.style.animation = `wobble var(--wobble-duration, 4s) ease-in-out infinite, blurPulse var(--blur-duration, 3s) ease-in-out infinite`;
                    letter.style.animationDelay = `var(--wobble-delay, 0s), var(--blur-delay, 0s)`;
                }
                
                // Platzhalter entfernen, falls vorhanden
                if (letterPlaceholder && letterPlaceholder.parentNode === wordContainer) {
                    const placeholderIndex = getDatasetInt(letterPlaceholder, 'letterIndex');
                    const letterIndex = getDatasetInt(letter, 'letterIndex');
                    
                    // Nur entfernen, wenn es der richtige Platzhalter ist
                    if (placeholderIndex === letterIndex) {
                        wordContainer.removeChild(letterPlaceholder);
                        letterPlaceholder = null;
                    }
                }
                
                // Zurück zum ursprünglichen Wort-Container in korrekter Reihenfolge hinzufügen
                const letterIndex = getDatasetInt(letter, 'letterIndex');
                const existingLetters = wordContainer.querySelectorAll('.letter:not(.letter-placeholder)');
                
                // Korrekten Einfügepunkt basierend auf letterIndex finden
                let insertBefore = null;
                for (let i = 0; i < existingLetters.length; i++) {
                    const existingIndex = getDatasetInt(existingLetters[i], 'letterIndex');
                    if (existingIndex > letterIndex) {
                        insertBefore = existingLetters[i];
                        break;
                    }
                }
                
                // Falls kein passender Buchstabe gefunden, prüfe auch Platzhalter
                if (!insertBefore) {
                    const placeholders = wordContainer.querySelectorAll('.letter-placeholder');
                    for (let i = 0; i < placeholders.length; i++) {
                        const placeholderIndex = getDatasetInt(placeholders[i], 'letterIndex');
                        if (placeholderIndex > letterIndex) {
                            insertBefore = placeholders[i];
                            break;
                        }
                    }
                }
                
                if (insertBefore) {
                    wordContainer.insertBefore(letter, insertBefore);
                } else {
                    wordContainer.appendChild(letter);
                }
                
                // Basis-Transform-Werte NACH dem Hinzufügen zum Container wiederherstellen
                // Stellt sicher, dass Hitbox korrekt positioniert ist
                updateLetterBaseTransform(letter);
                
                // Weitere Reflow erzwingen, um sicherzustellen, dass Transform angewendet ist
                void letter.offsetHeight;
                
                letter.dataset.inSlot = 'false';
                
                // Filled-Klasse von jedem Slot entfernen, der diesen Buchstaben hatte
                const slots = document.querySelectorAll('.drop-slot');
                slots.forEach(slot => {
                    if (slot.querySelector('.letter') === letter) {
                        slot.classList.remove('filled');
                    }
                });
            }
        }

        // ============================================================================
        // UI-HILFSFUNKTIONEN
        // ============================================================================
        
        /**
         * Zeigt die Drop-Zone an
         * @returns {void}
         */
        function showDropZone() {
            if (!cachedElements.dropZone) {
                cachedElements.dropZone = document.getElementById('drop-zone');
            }
            cachedElements.dropZone.classList.add('visible');
            dropZoneVisible = true;
        }

        /**
         * Zeigt den vertikalen Pfeil über der Drop-Zone an
         * @returns {void}
         */
        function showDropArrow() {
            if (!cachedElements.dropArrow) {
                cachedElements.dropArrow = document.getElementById('drop-arrow');
            }
            if (cachedElements.dropArrow) {
                cachedElements.dropArrow.classList.add('visible');
            }
        }

        /**
         * Verschiebt nicht-gezogene Buchstaben nach oben
         * @returns {void}
         */
        function slideUpNonDraggedLetters() {
            if (!cachedElements.wordsContainer) {
                cachedElements.wordsContainer = document.getElementById('words-container');
            }
            if (cachedElements.wordsContainer && !cachedElements.wordsContainer.classList.contains('shifted-up')) {
                cachedElements.wordsContainer.classList.add('shifted-up');
            }
        }

        // ============================================================================
        // LÖSUNGS-PRÜFUNG & RESET
        // ============================================================================
        
        /**
         * Prüft, ob die aktuelle Lösung korrekt ist
         * Löst ein Custom-Event aus, wenn die Lösung vollständig ist
         * @returns {void}
         */
        function checkSolution() {
            const wordRows = document.querySelectorAll('.word-row-slots');
            const words = [];
            
            wordRows.forEach(wordRow => {
                const slots = wordRow.querySelectorAll('.drop-slot');
                let word = '';
                slots.forEach(slot => {
                    const letter = slot.querySelector('.letter');
                    if (letter) {
                        word += letter.dataset.letter;
                    }
                });
                if (word) {
                    words.push(word);
                }
            });

            // Lösungs-String mit Leerzeichen erstellen
            const solution = words.join(' ');

            // Leerzeichen entfernen und vergleichen
            const solutionWithoutSpaces = solution.replace(/\s/g, '');
            const targetWithoutSpaces = targetSolution.replace(/\s/g, '');

            if (solutionWithoutSpaces === targetWithoutSpaces) {
                // Wortgrenzen prüfen
                const targetWords = targetSolution.split(' ');
                
                if (words.length === targetWords.length) {
                    let isCorrect = true;
                    for (let i = 0; i < words.length; i++) {
                        if (words[i] !== targetWords[i]) {
                            isCorrect = false;
                            break;
                        }
                    }
                    
                    if (isCorrect) {
                        // Custom-Event für zukünftige Erweiterungen auslösen
                        const event = new CustomEvent('anagramSolved', {
                            detail: { solution: targetSolution }
                        });
                        document.dispatchEvent(event);
                    }
                }
            }
        }

        /**
         * Setzt den Inaktivitäts-Timer zurück
         * Wird bei jeder Interaktion aufgerufen
         * @returns {void}
         */
        function resetInactivityTimer() {
            if (resetTimer) {
                clearTimeout(resetTimer);
            }
            
            resetTimer = setTimeout(() => {
                resetGame();
            }, RESET_TIMEOUT);
        }

        /**
         * Setzt das Spiel in den Ausgangszustand zurück
         * Versteckt Drop-Zone, setzt alle Buchstaben zurück und startet Animationen neu
         * @returns {void}
         */
        function resetGame() {
            // Stoppe Feuerwerks-Show wenn aktiv
            if (typeof stopFireworks === 'function') {
                stopFireworks();
            }
            
            // Zuerst Drop-Zone mit sanftem Übergang verstecken
            if (!cachedElements.dropZone) {
                cachedElements.dropZone = document.getElementById('drop-zone');
            }
            cachedElements.dropZone.classList.remove('visible');
            dropZoneVisible = false;

            // Drop-Pfeil verstecken
            if (!cachedElements.dropArrow) {
                cachedElements.dropArrow = document.getElementById('drop-arrow');
            }
            if (cachedElements.dropArrow) {
                cachedElements.dropArrow.classList.remove('visible');
            }

            // Wörter-Container-Position mit sanftem Übergang zurücksetzen
            if (!cachedElements.wordsContainer) {
                cachedElements.wordsContainer = document.getElementById('words-container');
            }
            if (cachedElements.wordsContainer) {
                cachedElements.wordsContainer.classList.remove('shifted-up');
                cachedElements.wordsContainer.classList.remove('win-image-visible');
            }
            const winImageContainer = document.getElementById('win-image-container');
            if (winImageContainer) {
                winImageContainer.classList.remove('visible');
            }
            document.body.classList.remove('win-mode');
            
            // Cache invalidieren, da Slots sich ändern können
            cachedElements.slots = null;
            
            // Alle Platzhalter entfernen
            const allPlaceholders = document.querySelectorAll('.letter-placeholder');
            allPlaceholders.forEach(placeholder => {
                if (placeholder.parentNode) {
                    placeholder.parentNode.removeChild(placeholder);
                }
            });
            letterPlaceholder = null;

            // Warten, bis Übergänge abgeschlossen sind, bevor Chaos-Phase beginnt
            setTimeout(() => {
                // Nur Buchstaben sammeln, die zurückgesetzt werden müssen (aus Slots oder gezogen)
                const lettersToReset = [];
                
                // Buchstaben aus Slots sammeln
                if (!cachedElements.slots) {
                    cachedElements.slots = document.querySelectorAll('.drop-slot');
                }
                cachedElements.slots.forEach(slot => {
                    const letter = slot.querySelector('.letter');
                    if (letter) {
                        // Position VOR dem Entfernen aus dem DOM ermitteln
                        const center = getElementCenter(letter);
                        
                        // Vom Slot entfernen
                        slot.removeChild(letter);
                        slot.classList.remove('filled');
                        // Zum Body hinzufügen für Reset-Animation
                        document.body.appendChild(letter);
                        
                        // Sofort feste Position setzen, um Sprung zu (0,0) zu verhindern
                        letter.style.position = 'fixed';
                        letter.style.left = center.x + 'px';
                        letter.style.top = center.y + 'px';
                        letter.style.transform = 'translate(-50%, -50%)';
                        letter.style.zIndex = Z_INDEX_ANIMATION;
                        
                        lettersToReset.push(letter);
                    }
                });

                // Nur Buchstaben sammeln, die NICHT in ihren ursprünglichen Containern sind
                // (d.h. Buchstaben, die gezogen aber nicht in Slots platziert wurden)
                letters.forEach(letter => {
                    // Überspringe Buchstaben, die bereits in ihren ursprünglichen Wort-Containern sind
                    // Diese sollten überhaupt nicht bewegt werden
                    if (letter.parentNode && letter.parentNode.classList.contains('word')) {
                        // Prüfe, ob Buchstabe im korrekten Wort-Container ist
                        const originalWord = letter.dataset.originalWord;
                        const wordContainerId = `word-${originalWord.toLowerCase()}`;
                        const wordContainer = document.getElementById(wordContainerId);
                        
                        // Nur zurücksetzen, wenn Buchstabe NICHT in seinem korrekten ursprünglichen Container ist
                        if (wordContainer && letter.parentNode !== wordContainer) {
                            // Position VOR dem Entfernen aus dem DOM ermitteln
                            const center = getElementCenter(letter);
                            
                            // Vom falschen Container entfernen
                            letter.parentNode.removeChild(letter);
                            // Zum Body hinzufügen für Reset-Animation
                            document.body.appendChild(letter);
                            
                            // Sofort feste Position setzen, um Sprung zu (0,0) zu verhindern
                            letter.style.position = 'fixed';
                            letter.style.left = center.x + 'px';
                            letter.style.top = center.y + 'px';
                            letter.style.transform = 'translate(-50%, -50%)';
                            letter.style.zIndex = Z_INDEX_ANIMATION;
                            
                            lettersToReset.push(letter);
                        }
                        // Wenn Buchstabe bereits im korrekten Container ist, nichts tun
                    } else if (letter.parentNode && letter.parentNode === document.body) {
                        // Buchstabe ist bereits im Body (vielleicht vom Dragging), zur Reset-Liste hinzufügen
                        lettersToReset.push(letter);
                    }
                });

                // Nur Buchstaben zurücksetzen, die tatsächlich verschoben werden müssen
                if (lettersToReset.length > 0) {
                    returnLettersToOriginalPositions(lettersToReset);
                }
            }, 500); // Warten auf Drop-Zone-Fade-Out

            // Gezogenen Buchstaben zurücksetzen
            draggedLetter = null;

        }

        /**
         * Setzt mehrere Buchstaben sanft an ihre ursprünglichen Positionen zurück
         * @param {Array<HTMLElement>|null} lettersToReset - Array von Buchstaben-Elementen oder null für alle
         * @returns {void}
         */
        function returnLettersToOriginalPositions(lettersToReset = null) {
            // Bereitgestellte Buchstaben verwenden oder alle, falls keine bereitgestellt wurden
            const lettersToProcess = lettersToReset || letters;
            
            // Ursprüngliche Positionen für jeden Buchstaben speichern
            const letterOriginalPositions = new Map();
            
            lettersToProcess.forEach(letter => {
                const originalWord = letter.dataset.originalWord;
                const wordContainerId = `word-${originalWord.toLowerCase()}`;
                const wordContainer = document.getElementById(wordContainerId);
                
                if (wordContainer) {
                    const letterIndex = parseInt(letter.dataset.letterIndex) || 0;
                    
                    // Ursprüngliche Position basierend auf Container und Buchstaben-Index berechnen
                    const containerRect = wordContainer.getBoundingClientRect();
                    const containerCenterX = containerRect.left + (containerRect.width / 2);
                    const containerCenterY = containerRect.top + (containerRect.height / 2);
                    
                    // Buchstaben-Position innerhalb des Wortes schätzen
                    const letterSpacing = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--source-letter-spacing')) || 0;
                    const estimatedLetterWidth = 60;
                    const totalWordWidth = (originalWord.length - 1) * (estimatedLetterWidth + letterSpacing);
                    const startX = containerCenterX - (totalWordWidth / 2);
                    const letterX = startX + (letterIndex * (estimatedLetterWidth + letterSpacing)) + (estimatedLetterWidth / 2);
                    
                    letterOriginalPositions.set(letter, {
                        container: wordContainer,
                        x: letterX,
                        y: containerCenterY,
                        letterIndex: letterIndex
                    });
                }

                // Sicherstellen, dass Position gesetzt ist (sollte bereits in resetGame gesetzt sein)
                if (!letter.style.position || letter.style.position !== 'fixed') {
                    const center = getElementCenter(letter);
                    letter.style.position = 'fixed';
                    letter.style.left = center.x + 'px';
                    letter.style.top = center.y + 'px';
                    letter.style.transform = 'translate(-50%, -50%)';
                    letter.style.zIndex = Z_INDEX_ANIMATION;
                }
                
                // Aktuelle Animationen stoppen
                letter.style.animation = 'none';
                letter.style.filter = 'blur(0px)';
                letter.style.opacity = '1';
            });

            // Buchstaben mit sanftem Übergang an ursprüngliche Positionen zurückbringen
            lettersToProcess.forEach((letter, index) => {
                const originalPos = letterOriginalPositions.get(letter);
                
                if (originalPos) {
                    // Rückgaben leicht versetzt für visuellen Effekt
                    setTimeout(() => {
                        // Sanften Übergang setzen
                        letter.style.transition = `left ${ANIMATION_DURATION_LONG}ms ease-out, top ${ANIMATION_DURATION_LONG}ms ease-out, transform ${ANIMATION_DURATION_LONG}ms ease-out`;
                        
                        // Zur ursprünglichen Position bewegen
                        letter.style.left = originalPos.x + 'px';
                        letter.style.top = originalPos.y + 'px';
                        letter.style.transform = 'translate(-50%, -50%)';
                        
                        // Nach Übergang zurück zum Container
                        setTimeout(() => {
                            returnLetterToOriginalPosition(letter);
                            
                            // Animationen wiederherstellen, nachdem alle Buchstaben zurück sind
                            if (index === lettersToProcess.length - 1) {
                                setTimeout(() => {
                                    lettersToProcess.forEach(l => {
                                        l.dataset.inSlot = 'false';
                                        
                                        // Individuelle Animation erneut aktivieren
                                        if (l.style.getPropertyValue('--wobble-delay')) {
                                            l.style.animation = `wobble var(--wobble-duration, 4s) ease-in-out infinite, blurPulse var(--blur-duration, 3s) ease-in-out infinite`;
                                            l.style.animationDelay = `var(--wobble-delay, 0s), var(--blur-delay, 0s)`;
                                        }
                                    });
                                }, ANIMATION_DURATION_LONG);
                            }
                        }, ANIMATION_DURATION_LONG);
                    }, index * STAGGER_DELAY);
                } else {
                    // Fallback: Wenn keine ursprüngliche Position gefunden wurde
                    returnLetterToOriginalPosition(letter);
                }
            });
        }

        // Initialisierung beim Laden
        window.addEventListener('DOMContentLoaded', initGame);

        // ============================================================================
        // FEUERWERKS-EFFEKT (wird bei Win-Condition ausgelöst)
        // ============================================================================
        
        let fireworksCanvas = null;
        let fireworksCtx = null;
        let fireworksActive = false;
        
        /**
         * Initialisiert das Feuerwerks-Canvas nach DOM-Load
         * @returns {void}
         */
        function initFireworksCanvas() {
            fireworksCanvas = document.getElementById('fireworks-canvas');
            if (!fireworksCanvas) return;
            fireworksCtx = fireworksCanvas.getContext('2d');
            resizeFireworksCanvas();
        }
        
        /**
         * Setzt die Canvas-Größe auf Fenstergröße
         * @returns {void}
         */
        function resizeFireworksCanvas() {
            if (!fireworksCanvas) return;
            fireworksCanvas.width = window.innerWidth;
            fireworksCanvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeFireworksCanvas);

        // Linien-Klasse (ersetzt Partikel)
        class FireworksLine {
            constructor(x, y, vx, vy, length, intensity, life = 1.0) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.length = length;
                this.intensity = intensity;
                this.life = life;
                this.maxLife = life;
                this.gravity = 0.1;
                this.friction = 0.99;
                this.maxLineWidth = 0.5 + Math.random() * 2.5;
                this.lineWidth = this.maxLineWidth;
                this.currentAngle = Math.atan2(vy, vx);
                this.rotationSpeed = 0.15;
            }

            update() {
                this.vy += this.gravity;
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.x += this.vx;
                this.y += this.vy;
                
                const targetAngle = Math.atan2(this.vy, this.vx);
                let angleDiff = targetAngle - this.currentAngle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                this.currentAngle += angleDiff * this.rotationSpeed;
                this.life -= 0.008;
            }

            draw() {
                const alpha = (this.life / this.maxLife) * this.intensity;
                if (alpha <= 0) return;
                
                const currentLineWidth = this.maxLineWidth * (this.life / this.maxLife);
                const currentLength = this.length * (0.7 + 0.3 * (this.life / this.maxLife));
                
                fireworksCtx.save();
                fireworksCtx.strokeStyle = `rgba(255, 255, 255, ${Math.min(alpha * 0.9, 0.9)})`;
                fireworksCtx.lineWidth = Math.max(currentLineWidth, 0.3);
                fireworksCtx.lineCap = 'round';
                
                const angle = this.currentAngle;
                const endX = this.x + Math.cos(angle) * currentLength;
                const endY = this.y + Math.sin(angle) * currentLength;
                
                fireworksCtx.beginPath();
                fireworksCtx.moveTo(this.x, this.y);
                fireworksCtx.lineTo(endX, endY);
                fireworksCtx.stroke();
                fireworksCtx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // Rakete-Klasse (Parabelbahn)
        class FireworksRocket {
            constructor(x, y, canvasHeight) {
                this.x = x;
                this.y = y;
                this.exploded = false;
                
                // Parabelbahn: Konstante horizontale Geschwindigkeit, vertikale durch Schwerkraft
                const horizontalSpeed = -2 + Math.random() * 4; // -2 bis +2 (links/rechts)
                this.vx = horizontalSpeed; // Konstante horizontale Geschwindigkeit
                
                this.gravity = 0.08; // Schwerkraft (reduziert für höhere Flugbahn)
                
                // Berechne Scheitelpunkt-Höhe: zwischen 50% und 100% der Bildschirmhöhe
                // Start ist unten (y = canvasHeight), Scheitelpunkt soll bei 50%-100% der Höhe sein
                // 50% der Bildschirmhöhe = canvasHeight * 0.5 (von oben), 100% = canvasHeight * 0.0 (ganz oben)
                // maxHeight soll zwischen 50% und 100% der Bildschirmhöhe sein
                const heightFactor = 0.1 + Math.random() * 0.5; // 0.5 bis 1.0 (50% bis 100% der Bildschirmhöhe)
                const maxHeight = canvasHeight * heightFactor; // Höhe über Start
                const apexY = y - maxHeight; // Scheitelpunkt Y-Koordinate
                
                // Berechne benötigte Startgeschwindigkeit für diese Höhe
                // Formel: h = vy^2 / (2 * g) => vy = -sqrt(2 * g * h)
                // Erhöhe die Geschwindigkeit deutlich, um sicherzustellen, dass die Höhe erreicht wird
                this.vy = -Math.sqrt(2 * this.gravity * maxHeight) * 1.3;
                
                this.startY = y; // Startposition
                this.apexY = apexY; // Ziel-Scheitelpunkt
                this.hasReachedApex = false; // Ob Scheitelpunkt erreicht wurde
                this.explosionDelay = 0.1 + Math.random() * 0.2; // Kurz nach Scheitelpunkt (0.1-0.3 Sekunden)
                this.fallTime = 0;
                
                // Trail für Schweif-Effekt
                this.trail = [];
                this.trailMaxLength = 30; // Maximale Anzahl von Trail-Punkten
                this.trailSpacing = 3; // Abstand zwischen Trail-Punkten
                this.lastTrailX = x;
                this.lastTrailY = y;
            }

            update() {
                if (!this.exploded) {
                    // Schwerkraft anwenden (immer)
                    this.vy += this.gravity;
                    
                    // Prüfe ob Scheitelpunkt erreicht (vy wechselt von negativ zu positiv)
                    if (!this.hasReachedApex && this.vy >= 0) {
                        this.hasReachedApex = true;
                        this.fallTime = 0;
                    }
                    
                    // Explodiere kurz nach Scheitelpunkt
                    if (this.hasReachedApex) {
                        this.fallTime += 1/60; // Annahme: 60 FPS
                        if (this.fallTime >= this.explosionDelay) {
                            this.exploded = true;
                            return true;
                        }
                    }
                    
                    // Position aktualisieren (Parabelbahn)
                    this.x += this.vx; // Konstante horizontale Bewegung
                    this.y += this.vy; // Vertikale Bewegung mit Schwerkraft
                    
                    // Trail-Punkte hinzufügen (nur wenn genug Abstand)
                    const distSinceLastTrail = Math.sqrt(
                        (this.x - this.lastTrailX) ** 2 + (this.y - this.lastTrailY) ** 2
                    );
                    if (distSinceLastTrail >= this.trailSpacing) {
                        this.trail.push({x: this.x, y: this.y});
                        this.lastTrailX = this.x;
                        this.lastTrailY = this.y;
                        
                        // Älteste Trail-Punkte entfernen
                        if (this.trail.length > this.trailMaxLength) {
                            this.trail.shift();
                        }
                    }
                }
                return false;
            }

            draw() {
                if (!this.exploded) {
                    // Zeichne Trail (Schweif) - von hinten nach vorne ausfadend
                    if (this.trail.length > 1) {
                        fireworksCtx.lineCap = 'round';
                        fireworksCtx.lineJoin = 'round';
                        
                        for (let i = 0; i < this.trail.length - 1; i++) {
                            const progress = i / (this.trail.length - 1); // 0 (hinten) bis 1 (vorne)
                            const alpha = 0.3 + progress * 0.6; // 0.3 (hinten) bis 0.9 (vorne)
                            const lineWidth = 1 + progress * 1.5; // 1 (hinten) bis 2.5 (vorne)
                            
                            fireworksCtx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                            fireworksCtx.lineWidth = lineWidth;
                            
                            fireworksCtx.beginPath();
                            fireworksCtx.moveTo(this.trail[i].x, this.trail[i].y);
                            fireworksCtx.lineTo(this.trail[i + 1].x, this.trail[i + 1].y);
                            fireworksCtx.stroke();
                        }
                    }
                    
                    // Zeichne Rakete selbst
                    fireworksCtx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                    fireworksCtx.lineWidth = 2.5;
                    fireworksCtx.lineCap = 'round';
                    const angle = Math.atan2(this.vy, this.vx);
                    const length = 10;
                    const endX = this.x + Math.cos(angle) * length;
                    const endY = this.y + Math.sin(angle) * length;
                    fireworksCtx.beginPath();
                    fireworksCtx.moveTo(this.x, this.y);
                    fireworksCtx.lineTo(endX, endY);
                    fireworksCtx.stroke();
                }
            }

            explode() {
                const lines = [];
                const lineCount = 20 + Math.random() * 20; // Reduziert von 40-80 auf 20-40
                for (let i = 0; i < lineCount; i++) {
                    const angle = (Math.PI * 2 * i) / lineCount + (Math.random() - 0.5) * 0.3;
                    const speed = Math.random() * 6 + 2;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    const lineLength = Math.random() * 10 + 5;
                    const intensity = 0.6 + Math.random() * 0.4;
                    const life = 0.8 + Math.random() * 0.4;
                    lines.push(new FireworksLine(this.x, this.y, vx, vy, lineLength, intensity, life));
                }
                return lines;
            }
        }

        // Arrays für Feuerwerks-Objekte
        let fireworksRockets = [];
        let fireworksLines = [];
        let rocketSpawnInterval = null; // Interval für kontinuierliches Spawnen
        
        // Performance-Optimierung: Maximale Anzahl von Linien
        const MAX_LINES = 500;

        /**
         * Feuerwerks-Animation-Loop
         * @returns {void}
         */
        function animateFireworks() {
            if (!fireworksActive || !fireworksCanvas || !fireworksCtx) return;
            
            // Transparenter Hintergrund (Overlay)
            fireworksCtx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
            
            // Leichtes Fade für Schweif-Effekt
            fireworksCtx.fillStyle = 'rgba(0, 100, 73, 0.05)'; // Hintergrundfarbe des Spiels
            fireworksCtx.fillRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);

            // Raketen aktualisieren und zeichnen (in-place, kein neues Array)
            for (let i = fireworksRockets.length - 1; i >= 0; i--) {
                const rocket = fireworksRockets[i];
                const shouldExplode = rocket.update();
                rocket.draw();
                if (shouldExplode) {
                    const newLines = rocket.explode();
                    // Begrenze Anzahl der Linien
                    const linesToAdd = Math.min(newLines.length, MAX_LINES - fireworksLines.length);
                    for (let j = 0; j < linesToAdd; j++) {
                        fireworksLines.push(newLines[j]);
                    }
                    fireworksRockets.splice(i, 1); // Entferne explodierte Rakete
                } else if (rocket.exploded) {
                    fireworksRockets.splice(i, 1); // Entferne explodierte Rakete
                }
            }

            // Linien aktualisieren und zeichnen (in-place, kein neues Array)
            for (let i = fireworksLines.length - 1; i >= 0; i--) {
                const line = fireworksLines[i];
                line.update();
                if (line.isDead()) {
                    fireworksLines.splice(i, 1);
                } else {
                    line.draw();
                }
            }

            // Animation weiterlaufen lassen, solange aktiv (Endlos-Loop)
            if (fireworksActive) {
                requestAnimationFrame(animateFireworks);
            }
        }

        /**
         * Erstellt eine neue Rakete
         * @returns {void}
         */
        function spawnRocket() {
            if (!fireworksActive || !fireworksCanvas) return;
            
            // 80% der Bildschirmbreite für Startposition
            const spawnWidth = fireworksCanvas.width * 0.8;
            const spawnStartX = fireworksCanvas.width * 0.1; // 10% vom linken Rand
            const startX = spawnStartX + Math.random() * spawnWidth;
            const startY = fireworksCanvas.height;
            fireworksRockets.push(new FireworksRocket(startX, startY, fireworksCanvas.height));
        }
        
        /**
         * Raketen-Spawn-Loop: Hält 10-25 Raketen aktiv
         * @returns {void}
         */
        function rocketSpawnLoop() {
            if (!fireworksActive) {
                if (rocketSpawnInterval) {
                    clearInterval(rocketSpawnInterval);
                    rocketSpawnInterval = null;
                }
                return;
            }
            
            // Zähle aktive Raketen (nicht explodiert)
            const activeRocketCount = fireworksRockets.filter(r => !r.exploded).length;
            const minRockets = 10;
            const maxRockets = 25;
            const targetRockets = minRockets + Math.floor(Math.random() * (maxRockets - minRockets + 1));
            
            // Spawne neue Raketen, wenn zu wenige aktiv sind
            // Spawne nur 1-2 Raketen pro Durchlauf für gleichmäßigeren Flow
            if (activeRocketCount < targetRockets) {
                const rocketsToSpawn = Math.min(2, targetRockets - activeRocketCount); // Maximal 2 pro Durchlauf
                for (let i = 0; i < rocketsToSpawn; i++) {
                    setTimeout(() => {
                        if (fireworksActive) {
                            spawnRocket();
                        }
                    }, i * 250); // Größere Staffelung für gleichmäßigeren Flow
                }
            }
        }
        
        /**
         * Startet die Feuerwerks-Show
         * @returns {void}
         */
        function startFireworks() {
            if (!fireworksCanvas || !fireworksCtx) {
                initFireworksCanvas();
                if (!fireworksCanvas || !fireworksCtx) return;
            }
            fireworksActive = true;
            fireworksRockets = [];
            fireworksLines = [];
            
            // Stoppe vorherigen Spawn-Interval falls vorhanden
            if (rocketSpawnInterval) {
                clearInterval(rocketSpawnInterval);
            }
            
            // Starte Animation-Loop sofort
            animateFireworks();
            
            // Starte kontinuierlichen Raketen-Spawn-Loop
            rocketSpawnLoop(); // Sofort ausführen
            rocketSpawnInterval = setInterval(() => {
                rocketSpawnLoop();
            }, 300); // Alle 300ms prüfen für gleichmäßigeren Flow
        }
        
        /**
         * Stoppt die Feuerwerks-Show
         * @returns {void}
         */
        function stopFireworks() {
            fireworksActive = false;
            if (rocketSpawnInterval) {
                clearInterval(rocketSpawnInterval);
                rocketSpawnInterval = null;
            }
            fireworksRockets = [];
            fireworksLines = [];
            
            // Canvas zurücksetzen/leeren
            if (fireworksCanvas && fireworksCtx) {
                fireworksCtx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
            }
        }

        /**
         * Event-Listener für Win-Condition
         * @param {Event} e - Das anagramSolved Event
         * @returns {void}
         */
        function handleAnagramSolved(e) {
            const winImageContainer = document.getElementById('win-image-container');
            const wordsContainer = document.getElementById('words-container');
            if (winImageContainer) {
                winImageContainer.classList.add('visible');
            }
            if (wordsContainer) {
                wordsContainer.classList.add('win-image-visible');
            }
            document.body.classList.add('win-mode');
            if (!cachedElements.dropArrow) {
                cachedElements.dropArrow = document.getElementById('drop-arrow');
            }
            if (cachedElements.dropArrow) {
                cachedElements.dropArrow.classList.remove('visible');
            }
            startFireworks();
        }
        document.addEventListener('anagramSolved', handleAnagramSolved);
        
        /**
         * Initialisiert das Feuerwerks-System nach DOM-Load
         * @returns {void}
         */
        function initializeFireworks() {
            initFireworksCanvas();
        }
        
        window.addEventListener('DOMContentLoaded', initializeFireworks);
        
        // Fallback: Initialisiere auch sofort, falls DOM bereits geladen ist
        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', initializeFireworks);
        } else {
            initializeFireworks();
        }

        // PWA: Service Worker registrieren (nur über HTTPS oder localhost)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js').catch(() => {});
            });
        }
    </script>
</body>
</html>
